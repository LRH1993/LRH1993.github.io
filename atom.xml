<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ruheng</title>
  
  <subtitle>成长路上的小菜鸟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lrh1993.github.io/"/>
  <updated>2018-07-01T09:16:58.369Z</updated>
  <id>https://lrh1993.github.io/</id>
  
  <author>
    <name>Ruheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android路由方案ARouter分析</title>
    <link href="https://lrh1993.github.io/2018/07/01/Android%E8%B7%AF%E7%94%B1%E6%96%B9%E6%A1%88ARouter%E5%88%86%E6%9E%90/"/>
    <id>https://lrh1993.github.io/2018/07/01/Android路由方案ARouter分析/</id>
    <published>2018-07-01T09:13:21.000Z</published>
    <updated>2018-07-01T09:16:58.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、路由方案"><a href="#一、路由方案" class="headerlink" title="一、路由方案"></a>一、路由方案</h2><h3 id="原生的路由方案缺点："><a href="#原生的路由方案缺点：" class="headerlink" title="原生的路由方案缺点："></a>原生的路由方案缺点：</h3><ul><li><p>显式：直接的类依赖，耦合严重</p></li><li><p>隐式：规则集中式管理，协作困难</p></li><li><p>Manifest扩展性较差</p></li><li><p>跳转过程无法控制</p></li><li><p>失败无法降级</p></li></ul><h3 id="ARouter的优势："><a href="#ARouter的优势：" class="headerlink" title="ARouter的优势："></a>ARouter的优势：</h3><ul><li><p>使用注解，实现了映射关系自动注册 与 分布式路由管理</p></li><li><p>编译期间处理注解，并生成映射文件，没有使用反射，不影响运行时性能</p></li><li><p>映射关系按组分类、多级管理，按需初始化</p></li><li><p>灵活的降级策略，每次跳转都会回调跳转结果，避免StartActivity()一旦失败将会抛出运营级异常</p></li><li><p>自定义拦截器，自定义拦截顺序，可以对路由进行拦截，比如登录判断和埋点处理</p></li><li><p>支持依赖注入，可单独作为依赖注入框架使用，从而实现 跨模块API调用</p></li><li><p>支持直接解析标准URL进行跳转，并自动注入参数到目标页面中</p></li><li><p>支持获取Fragment</p></li><li><p>支持多模块使用，支持组件化开发</p></li></ul><p>…….</p><p>这么多好处，是时候来了解一下<code>ARouter</code>了。</p><h2 id="二、ARouter框架"><a href="#二、ARouter框架" class="headerlink" title="二、ARouter框架"></a>二、ARouter框架</h2><p><img src="https://upload-images.jianshu.io/upload_images/3985563-7f6f9cc404e04329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是根据<code>ARouter</code>一次基本的路由导航过程，整理的基本框架图，涉及到主要流程，下面进行详细介绍。</p><h2 id="三、路由管理"><a href="#三、路由管理" class="headerlink" title="三、路由管理"></a>三、路由管理</h2><h3 id="1-注册"><a href="#1-注册" class="headerlink" title="1.注册"></a>1.注册</h3><p>通过注解，在编译时收集使用了注解的类或变量并经过Android Process Tool处理进行统一管理。</p><p>包含三种注解@Autowired，@Interceptor，@Route。</p><h4 id="Route"><a href="#Route" class="headerlink" title="@Route"></a>@Route</h4><p>注解定义<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> path();<span class="comment">//路径URL字符串</span></span><br><span class="line"><span class="keyword">String</span> group() <span class="built_in">default</span> <span class="string">""</span>;<span class="comment">//组名，默认为一级路径名；一旦被设置，跳转时必须赋值</span></span><br><span class="line"><span class="keyword">String</span> name() <span class="built_in">default</span> <span class="string">"undefined"</span>;<span class="comment">//该路径的名称，用于产生JavaDoc</span></span><br><span class="line"><span class="keyword">int</span> extras() <span class="built_in">default</span> Integer.MIN_VALUE;<span class="comment">//额外配置的开关信息；譬如某些页面是否需要网络校验、登录校验等</span></span><br><span class="line"><span class="keyword">int</span> priority() <span class="built_in">default</span> <span class="number">-1</span>;<span class="comment">//该路径的优先级</span></span><br></pre></td></tr></table></figure></p><p>实现 @Route 注解<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">BlankFragment               <span class="meta">@Route(path = <span class="meta-string">"/test/fragment"</span>)</span> </span><br><span class="line">Test1Activity               <span class="meta">@Route(path = <span class="meta-string">"/test/activity1"</span>)</span></span><br></pre></td></tr></table></figure></p><p>该注解主要用于描述路由中的路径URL信息，使用该注解标注的类将被自动添加至路由表中。</p><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>注解定义<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">boolean required()<span class="built_in"> default </span><span class="literal">false</span>;</span><br><span class="line">String desc()<span class="built_in"> default </span><span class="string">"No desc."</span>;</span><br></pre></td></tr></table></figure></p><p>实现 @Autowired 注解<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">Autowired</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">@<span class="keyword">Autowired</span></span><br><span class="line"><span class="keyword">HelloService</span> helloService;</span><br></pre></td></tr></table></figure></p><p>该注解是在页面跳转时参数传递用的。目标Class中使用该注解标志的变量，会在页面被路由打开的时候，在调用<code>inject()</code>后自动赋予传递的参数值。</p><h4 id="Interceptor"><a href="#Interceptor" class="headerlink" title="@Interceptor"></a>@Interceptor</h4><p>注解定义<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> priority();<span class="comment">//该拦截器的优先级</span></span><br><span class="line"><span class="keyword">String</span> name() <span class="built_in">default</span> <span class="string">"Default"</span>;<span class="comment">//该拦截器的名称，用于产生JavaDoc</span></span><br></pre></td></tr></table></figure></p><p>实现 @Interceptor 注解</p><p>一般应用于IInterceptor的实现类，是路由跳转过程中的拦截器，不分module，应用全局。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Interceptor</span>(priority = <span class="number">7</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1Interceptor</span> <span class="keyword">implements</span> <span class="title">IInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> InterceptorCallback callback)</span> </span>&#123;</span><br><span class="line">    ............</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-收集"><a href="#2-收集" class="headerlink" title="2.收集"></a>2.收集</h3><p>在编译期间自动生成映射文件，arouter-compiler实现了一些注解处理器,目标在于生成映射文件与辅助文件。<br><img src="https://upload-images.jianshu.io/upload_images/3985563-065a85c88ba9f710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>三种类型的注解处理器，都实现了<code>AbstractProcessor</code>,主要功能如下：</p><ul><li><p>首先通过注解处理器扫出被标注的类文件</p></li><li><p>按照不同种类的源文件进行分类</p></li><li><p>按照固定的命名格式生成映射文件</p></li></ul><p>这样就可以在运行期初始化的时候通过固定的包名来加载映射文件。</p><p>关于注解处理的源码详解见<a href="https://blog.csdn.net/crazy1235/article/details/77126904" target="_blank" rel="noopener">阿里路由框架–ARouter 源码解析之Compiler</a>。</p><p><img src="https://upload-images.jianshu.io/upload_images/3985563-5e141302f79a3d13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>以官方demo为例，通过注解处理器，按照固定的命名格式生成映射文件。</p><p>具体以<code>ARouter$$Root$$app</code>为例，看下注解处理器生成的类文件的内容：<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">public class ARouter<span class="symbol">$</span><span class="symbol">$</span>Root<span class="symbol">$</span><span class="symbol">$</span>app implements IRouteRoot &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) &#123;</span><br><span class="line">    routes.<span class="keyword">put</span>(<span class="string">"service"</span>, ARouter<span class="symbol">$</span><span class="symbol">$</span>Group<span class="symbol">$</span><span class="symbol">$</span>service.class);</span><br><span class="line">    routes.<span class="keyword">put</span>(<span class="string">"test"</span>, ARouter<span class="symbol">$</span><span class="symbol">$</span>Group<span class="symbol">$</span><span class="symbol">$</span>test.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过调用<code>loadInto()</code>方法将其管理的<code>group</code>类文件加载到集合中，方便后续路由查找。</p><h3 id="3-加载"><a href="#3-加载" class="headerlink" title="3.加载"></a>3.加载</h3><p>前面的收集都是在编译器处理获得的，那么加载就是到了运行期。<code>ARouter</code>为了避免内存和性能损耗，提出了“分组管理，按需加载”的方式。在前面的编译处理的过程中，已经按照不同种类生成对应的映射文件。</p><p>以官方demo为示例，一个app模块有一个Root结点，管理各个Group分组，每个Group分组下有着多个界面；此外app模块下还有着Interceptor结点，以及provider结点。</p><p>其中Interceptor结点对应于自定义的拦截器，provider结点对应于IOC，以实现跨模块API调用。</p><p><code>ARouter</code>在初始化的时候只会一次性地加载所有的root结点，而不会加载任何一个Group结点，这样就会极大地降低初始化时加载结点的数量。当某一个分组下的某一个页面第一次被访问的时候，整个分组的全部页面都会被加载进去。</p><h4 id="初始加载"><a href="#初始加载" class="headerlink" title="初始加载"></a>初始加载</h4><p><code>ARouter</code> 其实是一个代理类，它的所有函数实现都交给<code>_ARouter</code>去实现，两个都是单例模式。<br><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">public static void init(Application application) &#123;<span class="comment">//静态函数进行初始化，不依赖对象</span></span><br><span class="line">    <span class="keyword">if</span> (!hasInit) &#123;</span><br><span class="line">        logger = <span class="variable">_ARouter</span>.logger; <span class="comment">//持有 日志打印的 全局静态标量</span></span><br><span class="line">        <span class="variable">_ARouter</span>.logger.info(Consts.TAG, <span class="string">"ARouter init start."</span>);<span class="comment">//打印 ARouter初始化日志</span></span><br><span class="line">        hasInit = <span class="variable">_ARouter</span>.init(application);<span class="comment">//移交 _ARouter去 初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasInit) &#123;</span><br><span class="line">            <span class="variable">_ARouter</span>.afterInit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">_ARouter</span>.logger.info(Consts.TAG, <span class="string">"ARouter init over."</span>);<span class="comment">//打印 ARouter初始化日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续看一下<code>_ARouter</code>的初始化方法<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">boolean</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">        mContext = application;<span class="comment">// Application的上下文</span></span><br><span class="line">        LogisticsCenter.init(mContext, executor);<span class="comment">//移交逻辑中心进行初始化，并传入线城池对象</span></span><br><span class="line">        logger.info(Consts.TAG, <span class="string">"ARouter init success!"</span>);<span class="comment">//打印日志</span></span><br><span class="line">        hasInit = <span class="keyword">true</span>;<span class="comment">//标示是否初始化完成</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// It's not a good idea.</span></span><br><span class="line">        <span class="comment">// if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span></span><br><span class="line">        <span class="comment">//     application.registerActivityLifecycleCallbacks(new AutowiredLifecycleCallback());</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>继续往下走，看<code>LogisticsCenter</code>的初始化方法<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> init(Context context, ThreadPoolExecutor tpe) <span class="keyword">throws</span> HandlerException &#123;</span><br><span class="line">        mContext = context; <span class="comment">//静态持有Application的上下文</span></span><br><span class="line">        executor = tpe;<span class="comment">//静态持有 线城池</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// These class was generate by arouter-compiler.</span></span><br><span class="line">            <span class="comment">// 通过指定包名com.alibaba.android.arouter.routes，找到所有 编译期产生的routes目录下的类名(不包含装载类)</span></span><br><span class="line">            List&lt;String&gt; classFileNames = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String className : classFileNames) &#123;<span class="comment">//组别列表com.alibaba.android.arouter.routes.ARouter\$\$Root</span></span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class="line">                    <span class="comment">// This one of root elements, load root.</span></span><br><span class="line">                    ((IRouteRoot) (<span class="keyword">Class</span>.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;<span class="comment">//模块内的拦截器列表com.alibaba.android.arouter.routes.ARouter\$\$Interceptors</span></span><br><span class="line">                    <span class="comment">// Load interceptorMeta</span></span><br><span class="line">                    ((IInterceptorGroup) (<span class="keyword">Class</span>.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;<span class="comment">//IOC的动作路由列表com.alibaba.android.arouter.routes.ARouter\$\$Providers</span></span><br><span class="line">                    <span class="comment">// Load providerIndex</span></span><br><span class="line">                    ((IProviderGroup) (<span class="keyword">Class</span>.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Warehouse.groupsIndex.<span class="keyword">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(TAG, <span class="string">"No mapping files were found, check your configuration please!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]"</span>, Warehouse.groupsIndex.<span class="keyword">size</span>(), Warehouse.interceptorsIndex.<span class="keyword">size</span>(), Warehouse.providersIndex.<span class="keyword">size</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"ARouter init logistics center exception! ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过上述代码，实现了“分组管理，按需加载”的方式，加载了对应的三个注解处理器生成的类中管理的结点到路由集合中。<br><img src="https://upload-images.jianshu.io/upload_images/3985563-95096c9d71d93671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中内存仓库<code>Warehouse</code>缓存了全局应用的组别的清单列表、IOC的动作路由清单列表、模块内的拦截器清单列表，3个map对象。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warehouse</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Cache route and metas</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Class&lt;? <span class="keyword">extends</span> IRouteGroup&gt;&gt; groupsIndex = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//组别的列表 包含了组名与对应组内的路由清单列表Class的映射关系</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, RouteMeta&gt; routes = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//组内的路由列表 包含了对应分组下的，路由URL与目标对象Class的映射关系</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache provider</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">Map</span>&lt;Class, IProvider&gt; providers = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//缓存IOC  目标class与已经创建了的对象 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, RouteMeta&gt; providersIndex = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//IOC 的动作路由列表包含了使用依赖注入方式的某class的  路由URL 与class映射关系</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache interceptor</span></span><br><span class="line">    <span class="comment">//模块内的拦截器列表 包含了某个模块下的拦截器 与 优先级的映射关系</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">Map</span>&lt;Integer, Class&lt;? <span class="keyword">extends</span> IInterceptor&gt;&gt; interceptorsIndex = <span class="keyword">new</span> UniqueKeyTreeMap&lt;&gt;(<span class="string">"More than one interceptors use same priority [%s]"</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">List</span>&lt;IInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//已排序的拦截器实例对象</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四、路由查找"><a href="#四、路由查找" class="headerlink" title="四、路由查找"></a>四、路由查找</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">"/test/activity2"</span>).navigation();<span class="xml"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>以上述例子为例，看一下<code>ARouter</code>路由查找的过程。首先看一下<code>build</code>过程</p><h3 id="1-build"><a href="#1-build" class="headerlink" title="1.build()"></a>1.<code>build()</code></h3><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">public Postcard <span class="keyword">build</span>(<span class="keyword">String</span> <span class="keyword">path</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _ARouter.getInstance().<span class="keyword">build</span>(<span class="keyword">path</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Postcard <span class="keyword">build</span>(<span class="keyword">String</span> <span class="keyword">path</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(<span class="keyword">path</span>)) &#123;</span><br><span class="line">            throw new HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">            if (null != pService) &#123;</span><br><span class="line">                path = pService.forString(path);</span><br><span class="line">            &#125;</span><br><span class="line">            return <span class="keyword">build</span>(<span class="keyword">path</span>, extractGroup(<span class="keyword">path</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其使用了代理类_ARouter的build()并构建和返回PostCard对象。 一个Postcard对象就对应了一次路由请求，作用于本次路由全过程。</p><p>这部分代码主要包含两个部分：</p><ul><li>使用 IOC byType()方式寻找PathReplaceService.class接口的实现类，该实现类的作用就是实现 “运行期动态修改路由”。</li><li>继续进行本次路由导航</li></ul><p>首先来看一下PathReplaceService.class接口：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">PathReplaceService</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     * For normal path.</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     * @param path raw path</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="built_in">String</span> forString(<span class="built_in">String</span> path);</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     * For uri type.</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     *</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     * @param uri raw uri</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="built_in">Uri</span> forUri(<span class="built_in">Uri</span> uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要包含forString()和forUri两个方法，针对路径进行预处理，实现 “运行期动态修改路由”。</p><p>接下下，继续通过build(path, extractGroup(path))进行路由导航，其中extractGroup()是从路径中获取默认的分组信息。</p><p>然后build()方法会返回一个Postcard对象，并把对应的路径和分组信息传入该对象。</p><p>分析完上面的过程，下面来详细看下PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);中的navigation()方法，该方法实际调用了代理类_ARouter的navigation(Class&lt;? extends T&gt; service)方法。</p><h3 id="2-navigation-Class-lt-extends-T-gt-service"><a href="#2-navigation-Class-lt-extends-T-gt-service" class="headerlink" title="2.navigation(Class&lt;? extends T&gt; service)"></a>2.<code>navigation(Class&lt;? extends T&gt; service)</code></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T navigation(<span class="class"><span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">T</span>&gt; <span class="title">service</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Postcard postcard = LogisticsCenter.buildProvider(service.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compatible 1.0.5 compiler sdk.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123; <span class="comment">// No service, or this service in old version.</span></span><br><span class="line">            postcard = LogisticsCenter.buildProvider(service.getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">        <span class="keyword">return</span> (T) postcard.getProvider();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">        logger.warning(Consts.TAG, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先<code>LogisticsCenter.buildProvider(service.getName())</code>根据<code>Warehouse</code>保存的<code>providersIndex</code>的信息查找并构建返回一个<code>PostCard</code>对象</p></li><li><p>然后执行<code>LogisticsCenter.completion(postcard)</code>，该方法会根据<code>Warehouse</code>保存的<code>routes</code>的路由信息完善postcard对象，该方法在下面还会出现，到时候具体介绍</p></li></ul><p>再回到上文介绍<code>ARouter.getInstance().build(&quot;/test/activity2&quot;).navigation()</code>，返回<code>PostCard</code>对象后，开始调用对应的<code>navigation()</code>方法。</p><h3 id="3-navigation"><a href="#3-navigation" class="headerlink" title="3.navigation()"></a>3.<code>navigation()</code></h3><p>观察<code>PostCard</code>中的该方法<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">navigation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">navigation</span><span class="params">(<span class="keyword">null</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">navigation</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">navigation</span><span class="params">(context, <span class="keyword">null</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">navigation</span><span class="params">(Context context, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ARouter.getInstance().navigation(context, <span class="keyword">this</span>, <span class="number">-1</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">navigation</span><span class="params">(Activity mContext, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        navigation(mContext, requestCode, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">navigation</span><span class="params">(Activity mContext, <span class="keyword">int</span> requestCode, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        ARouter.getInstance().navigation(mContext, <span class="keyword">this</span>, requestCode, callback);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最终调用了<code>ARouter</code>中的<code>navigation()</code>方法，在其中其实是调用了<code>_ARouter</code>中的<code>navigation()</code>方法。</p><p>该方法包含查找回调的调用、降级处理、拦截器处理具体路由操作。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function">Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LogisticsCenter.completion(postcard);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">            logger.<span class="keyword">warning</span>(Consts.TAG, ex.getMessage());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (debuggable()) &#123; <span class="comment">// Show friendly tips for user.</span></span><br><span class="line">                Toast.makeText(mContext, <span class="string">"There's no route matched!\n"</span> +</span><br><span class="line">                        <span class="string">" Path = ["</span> + postcard.getPath() + <span class="string">"]\n"</span> +</span><br><span class="line">                        <span class="string">" Group = ["</span> + postcard.getGroup() + <span class="string">"]"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                callback.onLost(postcard);<span class="comment">//触发路由查找失败</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class="line">                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != degradeService) &#123;</span><br><span class="line">                    degradeService.onLost(context, postcard);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到了路由元信息，触发路由查找的回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">            callback.onFound(postcard);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//绿色通道校验 需要拦截处理</span></span><br><span class="line">        <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">            <span class="comment">//调用拦截器截面控制器，遍历内存仓库的自定义拦截器，并在异步线程中执行拦截函数</span></span><br><span class="line">            interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * Continue process</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> postcard route meta</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                    _navigation(context, postcard, requestCode, callback);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * Interrupt process, pipeline will be destory when this method called.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> exception Reson of interrupt.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                        callback.onInterrupt(postcard);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    logger.info(Consts.TAG, <span class="string">"Navigation failed, termination by interceptor : "</span> + exception.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">_navigation</span><span class="params">(context, postcard, requestCode, callback)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中最重要的两个方法就是<code>LogisticsCenter.completion()</code>和<code>_navigation()</code>，下面详细介绍。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public synchronized <span class="keyword">static</span> <span class="keyword">void</span> completion(Postcard postcard) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"No postcard!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据路径URL获取到路径元信息</span></span><br><span class="line">    RouteMeta routeMeta = Warehouse.routes.<span class="keyword">get</span>(postcard.getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123;    <span class="comment">// Maybe its does't exist, or didn't load.</span></span><br><span class="line">        <span class="comment">//可能没加载组内清单路径，从组别的清单列表拿到对应组</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.<span class="keyword">get</span>(postcard.getGroup());  <span class="comment">// Load route meta.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == groupMeta) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"There is no route match the path ["</span> + postcard.getPath() + <span class="string">"], in group ["</span> + postcard.getGroup() + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将该组的组内清单列表加入到内存仓库中，并把组别移除</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                    logger.debug(TAG, <span class="built_in">String</span>.format(Locale.getDefault(), <span class="string">"The group [%s] starts loading, trigger by [%s]"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">                iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                    logger.debug(TAG, <span class="built_in">String</span>.format(Locale.getDefault(), <span class="string">"The group [%s] has already been loaded, trigger by [%s]"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"Fatal exception when loading group meta. ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            completion(postcard);   <span class="comment">// 再次触发完善逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postcard.setDestination(routeMeta.getDestination());<span class="comment">//目标 class</span></span><br><span class="line">        postcard.setType(routeMeta.getType());<span class="comment">//路由类</span></span><br><span class="line">        postcard.setPriority(routeMeta.getPriority());<span class="comment">//路由优先级</span></span><br><span class="line">        postcard.setExtra(routeMeta.getExtra());<span class="comment">//额外的配置开关信息</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Uri</span> rawUri = postcard.getUri();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != rawUri) &#123;   <span class="comment">// Try to set params into bundle.</span></span><br><span class="line">            <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">            <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                <span class="comment">// Set value by its type, just for params which annotation by @Param</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">                    setValue(postcard,</span><br><span class="line">                            params.getValue(),</span><br><span class="line">                            params.getKey(),</span><br><span class="line">                            resultMap.<span class="keyword">get</span>(params.getKey()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Save params name which need auto inject.</span></span><br><span class="line">                postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> <span class="built_in">String</span>[]&#123;&#125;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save raw uri</span></span><br><span class="line">            postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></span><br><span class="line">                <span class="comment">// Its provider, so it must implement IProvider</span></span><br><span class="line">                Class&lt;? <span class="keyword">extends</span> IProvider&gt; providerMeta = (Class&lt;? <span class="keyword">extends</span> IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                IProvider instance = Warehouse.providers.<span class="keyword">get</span>(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There's no instance of this provider</span></span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Fragment needn't interceptors</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法就是完善<code>PostCard</code>，来实现一次路由导航。</p><p>接下来介绍另一个方法<code>_navigation()</code>。<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object _navigation(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback) &#123;</span><br><span class="line">        <span class="keyword">final</span> Context currentContext = <span class="literal">null</span> == context ? mContext : context;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">ACTIVITY:</span><span class="comment">//如果是Acitvity，则实现Intent跳转</span></span><br><span class="line">                <span class="comment">// Build intent</span></span><br><span class="line">                <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(currentContext, postcard.getDestination());</span><br><span class="line">                intent.putExtras(postcard.getExtras());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set flags.</span></span><br><span class="line">                <span class="keyword">int</span> flags = postcard.getFlags();</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> != flags) &#123;</span><br><span class="line">                    intent.setFlags(flags);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;    <span class="comment">// Non activity, need less one flag.</span></span><br><span class="line">                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Navigation in main looper.</span></span><br><span class="line">                <span class="keyword">new</span> Handler(Looper.getMainLooper()).post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                        <span class="keyword">if</span> (requestCode &gt; <span class="number">0</span>) &#123;  <span class="comment">// Need start for result</span></span><br><span class="line">                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> ((<span class="number">-1</span> != postcard.getEnterAnim() &amp;&amp; <span class="number">-1</span> != postcard.getExitAnim()) &amp;&amp; currentContext <span class="keyword">instanceof</span> Activity) &#123;    <span class="comment">// Old version.</span></span><br><span class="line">                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">null</span> != callback) &#123; <span class="comment">// Navigation over.</span></span><br><span class="line">                            callback.onArrival(postcard);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">PROVIDER:</span><span class="comment">//如果是IOC，则返回目标对象实例</span></span><br><span class="line">                <span class="keyword">return</span> postcard.getProvider();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">BOARDCAST:</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">CONTENT_PROVIDER:</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">FRAGMENT:</span><span class="comment">//如果是Fragment，则返回实例，并填充bundle</span></span><br><span class="line">                Class fragmentMeta = postcard.getDestination();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object instance = fragmentMeta.getConstructor().newInstance();</span><br><span class="line">                    <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> Fragment) &#123;</span><br><span class="line">                        ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class="line">                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> instance;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    logger.error(Consts.TAG, <span class="string">"Fetch fragment instance error, "</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">METHOD:</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">SERVICE:</span></span><br><span class="line"><span class="symbol">            default:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>至此我们就完成了一次路由跳转。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、路由方案&quot;&gt;&lt;a href=&quot;#一、路由方案&quot; class=&quot;headerlink&quot; title=&quot;一、路由方案&quot;&gt;&lt;/a&gt;一、路由方案&lt;/h2&gt;&lt;h3 id=&quot;原生的路由方案缺点：&quot;&gt;&lt;a href=&quot;#原生的路由方案缺点：&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://lrh1993.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Android多渠道打包相关</title>
    <link href="https://lrh1993.github.io/2018/06/23/Android%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E7%9B%B8%E5%85%B3/"/>
    <id>https://lrh1993.github.io/2018/06/23/Android多渠道打包相关/</id>
    <published>2018-06-23T00:59:21.000Z</published>
    <updated>2018-06-23T00:48:15.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、多渠道打包概述"><a href="#一、多渠道打包概述" class="headerlink" title="一、多渠道打包概述"></a>一、多渠道打包概述</h2><p>由于国内存在着有众多的应用市场，在不同的应用市场可能有不同的统计需求，为此Android开发人员需要为每个应用市场发布一个安装包，这里就引出了Android的多渠道打包。在安装包中添加不同的标识，以此区分各个渠道，方便统计app在市场的各种效果。</p><p>因此，每当发新版本时，市场会提供一个渠道列表，Android RD会根据这些渠道相应地生成等量的渠道包。随着渠道越来越多，为了提高渠道打包的效率，因此催生了对多渠道打包的方式的研究。</p><p>本篇文章主要总结一下多渠道打包的相关知识以及美团的新旧两种多渠道打包方案。</p><h2 id="二、渠道包生成"><a href="#二、渠道包生成" class="headerlink" title="二、渠道包生成"></a>二、渠道包生成</h2><p>Maven方式: 每打一个包都要执行一遍构建过程，效率太低;</p><p>apktool: 虽然不需要重新构建，但对每个包都要重新签名；</p><p>随着渠道包的增多，每次打包动辄几个小时，以上两种方式的效率太低。</p><p>关于这两种打包方式详见：<a href="https://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="noopener">美团Android自动化之旅—生成渠道包</a></p><h3 id="META-INF添加空文件"><a href="#META-INF添加空文件" class="headerlink" title="META-INF添加空文件"></a><code>META-INF</code>添加空文件</h3><p>这是美团为了提高打包效率而提出的一种新的多渠道打包方式，不需要重新构建，也不需要重新签名。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>通过解压apk，根目录下会有一个<code>META-INF</code>目录，在该目录下添加空文件，可以不用重新签名应用。因此，通过为不同渠道的应用添加不同的空文件，可以唯一标识一个渠道。</p><p><img src="https://upload-images.jianshu.io/upload_images/3985563-978960717052dd0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ul><li><p>利用python代码用来给apk添加空的渠道文件</p></li><li><p>在Java代码中读取空渠道文件名，识别渠道</p></li></ul><p>具体代码在上面美团生成多渠道包的链接中有详细给出。</p><h3 id="Walle"><a href="#Walle" class="headerlink" title="Walle"></a>Walle</h3><p>Walle（瓦力）：Android Signature V2 Scheme签名下的新一代渠道包打包神器</p><p>瓦力通过在Apk中的<code>APK Signature Block</code>区块添加自定义的渠道信息来生成渠道包，从而提高了渠道包生成效率，可以作为单机工具来使用，也可以部署在HTTP服务器上来实时处理渠道包Apk的升级网络请求。</p><h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><p>Android 7.0（Nougat）引入一项新的应用签名方案<a href="https://source.android.com/security/apksigning/v2.html" target="_blank" rel="noopener">APK Signature Scheme v2</a>，它是一个对全文件进行签名的方案，能提供更快的应用安装时间、对未授权APK文件的更改提供更多保护，在默认情况下，Android Gradle 2.2.0插件会使用APK Signature Scheme v2和传统签名方案来签署你的应用。</p><p><img src="https://upload-images.jianshu.io/upload_images/3985563-1daf14e4397b7bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>新应用签名方案的签名信息会被保存在区块（<code>APK Signing Block</code>）中， 而区块（<code>Contents of ZIP entries</code>）、区块（<code>ZIP Central Directory</code>）、区块（<code>ZIP End of Central Directory</code>）是受保护的，在签名后任何对其的修改都逃不过新的应用签名方案的检查。</p><p>之前的渠道包生成方案是通过在<code>META-INF</code>目录下添加空文件的打包方式在Signature Scheme v2的签名方式下不可使用了，因为<code>META-INF</code>已经被列入了保护区了，向<code>META-INF</code>添加空文件的方案会对上面受保护的三个区块都有影响。</p><p>通过上面描述发现区块（<code>APK Signing Block</code>）是不受签名校验规则保护的，因此Walle正是通过在该区块做文章，写入渠道信息。</p><h4 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h4><ul><li><p>对新的应用签名方案生成的APK包中区块（<code>APK Signing Block</code>）写入渠道信息，并保存在APK中</p></li><li><p>APK在安装过程中进行的签名校验，是忽略我们添加的渠道信息的，这样就能正常安装了</p></li><li><p>在App运行阶段，可以通过ZIP的<code>End of central directory</code>、<code>Central directory</code>等结构中的信息找到我们自己添加的渠道信息，从而实现获取渠道信息的功能</p></li></ul><p>最终，每打一个渠道包只需复制一个APK，然后在APK中添加一个渠道信息即可，这种打包方式速度非常快。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li><p>Gradle插件方式，方便快速集成</p></li><li><p>命令行方式，最大化满足各种自定义需求</p></li></ul><p>关于Walle两种使用方式的详细步骤，参见：<a href="https://blog.csdn.net/johnwcheung/article/details/60573397" target="_blank" rel="noopener">Android使用walle多渠道打包</a></p><h2 id="三、渠道包适配"><a href="#三、渠道包适配" class="headerlink" title="三、渠道包适配"></a>三、渠道包适配</h2><p>上述多渠道打包方式解决了打包慢的问题，但是随着渠道越来越多，不同渠道对应用的要求也不尽相同。</p><p>例如，有的渠道要求app的应用名不同，有些渠道要求应用不能使用第三方统计工具，有些渠道要求应用不能自动更新。</p><p>之前的做法是为每个需要适配的渠道创建一个Git分支，发版时再切换到相应的分支，并合并主分支的代码。适配的渠道比较少的话这种方式还可以接受，随着适配渠道的增多，这种方式就变得不可取。</p><p>幸好Gradle flavor，可以满足渠道适配的需求，只需要通过配置Gradle即可以实现多渠道的适配工作，省心省力。</p><h3 id="Flavor"><a href="#Flavor" class="headerlink" title="Flavor"></a>Flavor</h3><p>先来看<code>build.gradle</code>文件中的一段代码：<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="class">android </span>&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="class">productFlavors </span>&#123;</span><br><span class="line">        <span class="class">flavor1 </span>&#123;</span><br><span class="line">            minSdkVersion <span class="number">14</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上例定义了一个<code>flavor</code>：<code>flavor1</code>，并指定了应用的<code>minSdkVersion</code>为14（当然还可以配置更多的属性，具体可参考相关文档）。与此同时，Gradle还会为该<code>flavor</code>关联对应的<code>sourceSet</code>，默认位置为<code>src/&lt;flavorName&gt;</code>目录，对应到本例就是<code>src/flavor1</code>。</p><p>接下来，要做的就是根据具体的需求在<code>build.gradle</code>文件中配置<code>flavor</code>，并添加必要的代码和资源文件。以<code>flavor1</code>为例，运行<code>gradle assembleFlavor1</code>命令既可生成所需的适配包。通过适配不同的<code>flavor</code>即可以生成不同的渠道包，但该方式生成渠道包的方式需要重复编译构建。</p><h3 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h3><h4 id="使用不同的包名"><a href="#使用不同的包名" class="headerlink" title="使用不同的包名"></a>使用不同的包名</h4><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">    <span class="string">qq &#123;</span></span><br><span class="line"><span class="string">        applicationId "com.hello.group.qq"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面的代码添加了一个名为<code>qq</code>的flavor，并指定了应用的包名为<code>com.hello.group.qq</code>，运行<code>gradle assembleqq</code>命令即可生成qq适配包。</p><h4 id="使用不同的应用名"><a href="#使用不同的应用名" class="headerlink" title="使用不同的应用名"></a>使用不同的应用名</h4><p>Gradle在构建应用时，会优先使用<code>flavor</code>所属<code>sourceSet</code>中的同名资源。所以，解决思路就是在<code>flavor</code>的<code>sourceSet</code>中添加同名的字符串资源，以覆盖默认的资源。</p><p>首先，在<code>build.gradle</code>配置文件中添加如下flavor：<br><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="class">android </span>&#123;</span><br><span class="line">    <span class="class">productFlavors </span>&#123;</span><br><span class="line">        <span class="class">wandoujia </span>&#123; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的配置会默认<code>src/wandoujia</code>目录为<code>wandoujia</code> flavor的<code>sourceSet</code>。</p><p>接下来，在<code>src</code>目录内创建<code>wandoujia</code>目录，并添加如下应用名字符串资源（<code>src/wandoujia/res/values/appname.xml</code>）：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>wandoujia_app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>默认的应用名字符串资源如下（<code>src/main/res/values/strings.xml</code>）:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>origin_app<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>最后，运行<code>gradle assembleWandoujia</code>命令即可生成应用名为<code>wandoujia_app</code>的应用了。</p><p><strong>wandoujia包下不使用strings.xml 名是因为会出现文件重复，默认的main 文件夹里存在的文件在其他适配目录中不允许出现相同文件名的文件。</strong></p><p>更多<code>flavor</code>适配示例，参见：<a href="https://tech.meituan.com/mt-apk-adaptation.html" target="_blank" rel="noopener">美团Android自动化之旅—适配渠道包</a></p><p>以上就是最近了解关于多渠道打包的相关知识的总结。</p><p>想要实现更多自定义适配多渠道包的需求，还要更多的了解Gradle相关知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、多渠道打包概述&quot;&gt;&lt;a href=&quot;#一、多渠道打包概述&quot; class=&quot;headerlink&quot; title=&quot;一、多渠道打包概述&quot;&gt;&lt;/a&gt;一、多渠道打包概述&lt;/h2&gt;&lt;p&gt;由于国内存在着有众多的应用市场，在不同的应用市场可能有不同的统计需求，为此Andro
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://lrh1993.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>碎阅：一款基于douban及ONE API开发的资讯类App</title>
    <link href="https://lrh1993.github.io/2018/03/16/%E7%A2%8E%E9%98%85%EF%BC%9A%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8Edouban%E5%8F%8AONE-API%E5%BC%80%E5%8F%91%E7%9A%84%E8%B5%84%E8%AE%AF%E7%B1%BBApp/"/>
    <id>https://lrh1993.github.io/2018/03/16/碎阅：一款基于douban及ONE-API开发的资讯类App/</id>
    <published>2018-03-16T01:33:21.000Z</published>
    <updated>2018-03-16T01:51:11.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一款基于douban及ONE API开发的资讯类的开源项目。项目采取的是okhttp + MVP架构开发。Github地址：<a href="https://github.com/LRH1993/SuiYue" target="_blank" rel="noopener">https://github.com/LRH1993/SuiYue</a></p></blockquote><h2 id="一、效果图"><a href="#一、效果图" class="headerlink" title="一、效果图"></a>一、效果图</h2><table><thead><tr><th><img src="https://upload-images.jianshu.io/upload_images/3985563-0511e76b2586caed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文章页面"></th><th><img src="https://upload-images.jianshu.io/upload_images/3985563-14cbc9d75c05ea9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图书页面"></th><th><img src="https://upload-images.jianshu.io/upload_images/3985563-f49b76a0036c3c74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电影页面"></th></tr></thead><tbody><tr><td><img src="https://upload-images.jianshu.io/upload_images/3985563-28e8db39f2088d17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文章详情页"></td><td><img src="https://upload-images.jianshu.io/upload_images/3985563-f8b6399f512d3c25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图书详情页"></td><td><img src="https://upload-images.jianshu.io/upload_images/3985563-a288b2f6cce7eb3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电影详情页"></td></tr><tr><td><img src="https://upload-images.jianshu.io/upload_images/3985563-d0af9ae23b6ed174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜索页面"></td><td><img src="https://upload-images.jianshu.io/upload_images/3985563-4c5b0a8efe9dc007.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="扫描页面"></td><td><img src="https://upload-images.jianshu.io/upload_images/3985563-6ae55947995001d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="电影列表页面"></td></tr></tbody></table><h2 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h2><p>碎阅分为三个主要模块：</p><ul><li>文章</li><li>图书</li><li>电影</li></ul><h3 id="1-文章"><a href="#1-文章" class="headerlink" title="1.文章"></a>1.文章</h3><blockquote><p>API使用的是ONE API，关于具体API参考该项目的REAMDE。</p></blockquote><ul><li><p>文章列表：支持上拉加载更多下拉刷新，列表使用RecyclerView，每日推荐新的文章。</p></li><li><p>文章详情页：主要分为短文、问答及连载三种类型文章，布局采用CoordinatorLayout。</p></li></ul><h3 id="2-图书"><a href="#2-图书" class="headerlink" title="2.图书"></a>2.图书</h3><blockquote><p>API使用的是豆瓣图书 API，关于具体API参考该项目的REAMDE。</p></blockquote><ul><li><p>图书列表：列表使用RecyclerView，添加浮动按钮刷新图书，该按钮支持任意拖拽。</p></li><li><p>搜索界面：采用DialogFragment实现，支持历史搜索及热门搜索，具有Circular Reveal动画效果。</p></li><li><p>扫描界面：采用Zxing进行二维码扫描，支持图书扫描，获取图书详情信息。</p></li></ul><h3 id="3-电影"><a href="#3-电影" class="headerlink" title="3.电影"></a>3.电影</h3><blockquote><p>API使用的是豆瓣电影 API，关于具体API参考该项目的REAMDE。</p></blockquote><ul><li><p>电影列表：由影院热映、院线即将上映及豆瓣Top250三部分组成，点击全部跳转到显示所有列表信息。</p></li><li><p>电影详情页：影片的具体介绍及评分信息，采用CardView卡片控件，评分控件采用MaterialRatingbar。</p></li></ul><h2 id="三、开源库"><a href="#三、开源库" class="headerlink" title="三、开源库"></a>三、开源库</h2><ul><li><a href="https://github.com/facebook/fresco" target="_blank" rel="noopener">Fresco</a>，好用的图片加载库。</li><li><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">okhttp</a>，快速实现网络请求。</li><li><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a>，方便实现组件间通信。</li><li><a href="https://github.com/DreaminginCodeZH/MaterialRatingBar" target="_blank" rel="noopener">MaterialRatingBar</a>，符合material design的评分控件。</li><li><a href="https://github.com/zxing/zxing" target="_blank" rel="noopener">zxing</a>，google出品的二维码库。</li><li><a href="https://github.com/journeyapps/zxing-android-embedded" target="_blank" rel="noopener">zxing-android-embedded</a>，快速适用于android二维码使用的库。</li><li><a href="https://github.com/gyf-dev/ImmersionBar" target="_blank" rel="noopener">ImmersionBar</a>，简单实现各种状态栏管理。</li></ul><h2 id="四、技术点"><a href="#四、技术点" class="headerlink" title="四、技术点"></a>四、技术点</h2><p>在实现项目过程中，学到的一些知识，及遇到的一些技术问题。</p><ul><li><p>豆瓣及ONE的相关API的了解</p></li><li><p>Kotlin语言的使用及语法特性</p></li><li><p>MVP模式的特点及使用</p></li><li><p>Fresco的使用细节</p></li><li><p>okhttp的使用细节及简单封装</p></li><li><p>ZXing的接入以及在android中的使用</p></li><li><p>代码混淆的简单了解及学习</p></li><li><p>SwipeRefreshLayout结合RecyclerView下拉刷新上拉加载</p></li><li><p>CoordinatorLayout + Behavior的简单学习与使用</p></li><li><p>ScrollView嵌套RecyclerView的使用及问题分析</p></li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>由于时间原因以及相关API数据的限制，有些实现上比较粗糙，同时存在一些潜在的bug，欢迎在Github上提issue。如果觉得不错，对你有帮助，希望多多fork，star。</p><p><strong>Github地址：<a href="https://github.com/LRH1993/SuiYue" target="_blank" rel="noopener">https://github.com/LRH1993/SuiYue</a></strong><br><img src="https://upload-images.jianshu.io/upload_images/3985563-0ec22db89c7c5e02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以通过扫描二维码，下载apk体验。</p><p>​<br>​                      </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一款基于douban及ONE API开发的资讯类的开源项目。项目采取的是okhttp + MVP架构开发。Github地址：&lt;a href=&quot;https://github.com/LRH1993/SuiYue&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="开源项目" scheme="https://lrh1993.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>ScrollView嵌套RecyclerView滑动冲突相关问题</title>
    <link href="https://lrh1993.github.io/2018/03/14/ScrollView%E5%B5%8C%E5%A5%97RecyclerView%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://lrh1993.github.io/2018/03/14/ScrollView嵌套RecyclerView滑动冲突相关问题/</id>
    <published>2018-03-14T07:33:21.000Z</published>
    <updated>2018-03-15T01:55:12.094Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近实际应用中遇到了滑动冲突的相关问题，在解决过程中，有些需要注意的问题，特别记录一下。</p></blockquote><h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>在解决具体问题之前，先介绍下实际应用场景及问题状况。<br><img src="https://upload-images.jianshu.io/upload_images/3985563-f3d215ecdb5c06b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>从图中可以看出，一个ScrollView内部嵌套三个RecyclerView，其中两个RecyclerView是横向，一个RecyclerView是纵向。</p><p>在这个场景下，出现了滑动冲突问题，主要表现为横向RecyclerView滑动不灵敏，纵向RecyclerView滑动卡顿。</p><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><h3 id="1-横向RecyclerView滑动不灵敏"><a href="#1-横向RecyclerView滑动不灵敏" class="headerlink" title="1.横向RecyclerView滑动不灵敏"></a>1.横向RecyclerView滑动不灵敏</h3><p><img src="https://upload-images.jianshu.io/upload_images/3985563-d28a60f9b90db420.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>该问题所产生的滑动冲突如上图所示。</p><p>针对该问题，解决的方案是根据当前滑动方向，水平还是垂直来判断这个事件到底该交给谁来处理。</p><p>一般情况下根据滑动路径形成的夹角（或者说是斜率如下图）、水平和竖直方向滑动速度差来判断。<br><img src="https://upload-images.jianshu.io/upload_images/3985563-e8f50b90995abc06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2-纵向RecyclerView滑动卡顿"><a href="#2-纵向RecyclerView滑动卡顿" class="headerlink" title="2.纵向RecyclerView滑动卡顿"></a>2.纵向RecyclerView滑动卡顿</h3><p><img src="https://upload-images.jianshu.io/upload_images/3985563-4d720b11b84bb15d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>该问题所产生的滑动冲突如上图所示。</p><p>针对该问题，一般情况下必需通过业务逻辑来进行判断，决定到底谁来处理该事件。</p><h2 id="三、滑动冲突解决方法"><a href="#三、滑动冲突解决方法" class="headerlink" title="三、滑动冲突解决方法"></a>三、滑动冲突解决方法</h2><p>针对滑动冲突，一般有两个解决方法。</p><h3 id="1-外部拦截法"><a href="#1-外部拦截法" class="headerlink" title="1.外部拦截法"></a>1.外部拦截法</h3><p>事件都先经过父容器的拦截处理，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题。外部拦截法需要重写父容器的<code>onInterceptTouchEvent()</code>方法，在内部完成相应的拦截即可<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.<span class="string">ACTION_DOWN:</span></span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.<span class="string">ACTION_MOVE:</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要事件) &#123;</span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.<span class="string">ACTION_UP:</span> &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>ACTION_DOWN 这个事件里父容器必须返回 false，即不拦截ACTION_DOWN事件，因为一旦拦截了那么后续的 ACTION_MOVE、ACTION_UP都由父容器去处理，事件就无法传到子view了</p></li><li><p>ACTION_MOVE 事件可以根据需要来进行拦截或者不拦截</p></li><li><p>ACTION_UP 这个事件必须返回false，就会导致子View无法接受到UP事件，这个时候子元素中的<code>onClick()</code>事件就无法处触发。</p><h3 id="2-内部拦截法"><a href="#2-内部拦截法" class="headerlink" title="2.内部拦截法"></a>2.内部拦截法</h3><p>父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理。这种方法需要配合<code>requestDisallowInterceptTouchEvent()</code>方法才能正常工作。</p></li></ul><p>主要是修改子view的<code>dispatchTouchEvent()</code>方法<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.<span class="string">ACTION_DOWN:</span> &#123;</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.<span class="string">ACTION_MOVE:</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要此类事件) &#123;</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.<span class="string">ACTION_UP:</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>父容器需要重写<code>onInterceptTouchEvent()</code>方法<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">    <span class="keyword">if</span>(action == MotionEvent.ACTION_DOWN)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>父容器拦截ACTION_DOWN以外的其他事件，因为ACTION_DOWN 事件不受 FLAG_DISALLOW_INTERCEPT这个标记的控制，所以<strong>一旦父容器拦截了ACTION_DOWN 事件那么所有的事件都无法传到子view中去了</strong>，这样内部拦截法就不起作用了。</p><h2 id="四、问题解决"><a href="#四、问题解决" class="headerlink" title="四、问题解决"></a>四、问题解决</h2><p>下面就来实际解决本文中遇到的滑动冲突问题。通过上述分析可知，本文所遇到的问题通过外部拦截法，重写ScrollView的<code>onInterceptTouchEvent()</code>方法即可快速简单的解决。<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FScrollView</span> <span class="keyword">extends</span> <span class="title">ScrollView</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mLastXIntercept = <span class="number">0</span>f;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mLastYIntercept = <span class="number">0</span>f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FScrollView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> intercepted = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">float</span> x = ev.getX();</span><br><span class="line">        <span class="keyword">float</span> y = ev.getY();</span><br><span class="line">        <span class="keyword">int</span> action = ev.getAction() &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.<span class="string">ACTION_DOWN:</span> &#123;</span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//初始化mActivePointerId</span></span><br><span class="line">                <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.<span class="string">ACTION_MOVE:</span> &#123;</span><br><span class="line">                <span class="comment">//横坐标位移增量</span></span><br><span class="line">                <span class="keyword">float</span> deltaX = x - mLastXIntercept;</span><br><span class="line">                <span class="comment">//纵坐标位移增量</span></span><br><span class="line">                <span class="keyword">float</span> deltaY = y - mLastYIntercept;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(deltaX) &lt; Math.abs(deltaY)) &#123;</span><br><span class="line">                    intercepted = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.<span class="string">ACTION_UP:</span> &#123;</span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastXIntercept = x;</span><br><span class="line">        mLastYIntercept = y;</span><br><span class="line">        <span class="keyword">return</span> intercepted;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>Math.abs(deltaX) &lt; Math.abs(deltaY)</code>表示横向位移增量小于于竖向位移增量，即竖直滑动，则ScrollView 拦截事件。</p></li><li><p><code>super.onInterceptTouchEvent(ev)</code>，初始化<code>mActivePointerId</code>，避免出现<code>Invalid pointerId=-1 in onTouchEvent</code>问题。</p></li><li><p>纵向RecyclerView的滑动被拦截，交给ScrollView处理，需要测量高度，会默认加载所有item，相当于LinearLayout，从而导致复用效率大大降低。所以如果情况复杂，建议采用头布局。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近实际应用中遇到了滑动冲突的相关问题，在解决过程中，有些需要注意的问题，特别记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、应用场景&quot;&gt;&lt;a href=&quot;#一、应用场景&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://lrh1993.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>从google-todo-mvp示例再次学习MVP</title>
    <link href="https://lrh1993.github.io/2018/02/28/%E4%BB%8Egoogle-todo-mvp%E7%A4%BA%E4%BE%8B%E5%86%8D%E6%AC%A1%E5%AD%A6%E4%B9%A0MVP/"/>
    <id>https://lrh1993.github.io/2018/02/28/从google-todo-mvp示例再次学习MVP/</id>
    <published>2018-02-28T03:28:21.000Z</published>
    <updated>2018-03-15T01:53:09.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>已经使用了一段时间的MVP模式，今天再以google官方的安卓架构示例todo-mvp为例，再次学习MVP模式。</p></blockquote><h2 id="一、MVP简介"><a href="#一、MVP简介" class="headerlink" title="一、MVP简介"></a>一、MVP简介</h2><p><img src="http://upload-images.jianshu.io/upload_images/3985563-25731fb5c707f5d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>Model: 数据层，负责与网络层和数据库层的逻辑交互。</li><li>View: UI层，显示数据, 并向Presenter报告用户行为。</li><li>Presenter: 从Model拿数据，应用到UI层，管理UI的状态，响应用户的行为。</li></ul><h2 id="二、MVP优势"><a href="#二、MVP优势" class="headerlink" title="二、MVP优势"></a>二、MVP优势</h2><p>在学习todo-mvp之前，先了解一下MVP的优势。</p><ul><li>分离了视图逻辑和业务逻辑，降低了耦合。</li><li>Activity只处理生命周期的任务，代码变得更加简洁。</li><li>视图逻辑和业务逻辑分别抽象到了View和Presenter的接口中，提高代码的阅读性。</li><li>Presenter被抽象成接口，可以有多种具体的实现，所以方便进行单元测试。</li><li>把业务逻辑抽到Presenter中去，避免后台线程引用着Activity导致Activity的资源无法被系统回收从而引起内存泄露和OOM。<h2 id="三、todo-mvp结构解析"><a href="#三、todo-mvp结构解析" class="headerlink" title="三、todo-mvp结构解析"></a>三、todo-mvp结构解析</h2><h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1.项目结构"></a>1.项目结构</h3><img src="http://upload-images.jianshu.io/upload_images/3985563-bf64641065361b3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>从上图可以看出，todo-mvp是按照功能模块划分的。</li></ul><p>其中tasks, taskdetail, addedittask, statistics是四个业务模块。</p><p>data是数据模块，其中具体的类<code>TasksRepository</code>担任Model层，负责远程和本地数据的获取。</p><p><code>BasePresenter</code>和<code>BaseView</code>是presenter 和 view 的基类，在具体模块承担实际功能。最后，util是工具类集合。</p><h3 id="2-具体解析"><a href="#2-具体解析" class="headerlink" title="2.具体解析"></a>2.具体解析</h3><p>在todoapp中，MVP的具体结构如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/3985563-4634a04a1a55cd1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>下面以tasks模块具体阐述上述图片中的实际作用关系。</p><p><strong>基类</strong><br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>BasePresenter &#123;</span><br><span class="line"></span><br><span class="line">    void start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>start()</code>方法的作用是presenter开始获取数据并调用view中方法改变界面显示，其调用时机是在Fragment类的<code>onResume</code>方法中。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>BaseView&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void setPresenter(T presenter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>setPresenter()</code>方法作用是在将presenter实例传入view中，其<strong>调用时机是presenter实现类的构造函数中</strong>。</p><p><strong>契约类</strong></p><p>与之前使用的MVP实现不同，官方的实现中加入了契约类来统一管理view与presenter的所有的接口，这种方式使得view与presenter中有哪些功能，一目了然，维护起来也方便，同时使得view与presenter一一对应，并有效地减少类的数目。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TasksContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">BaseView</span>&lt;<span class="title">Presenter</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setLoadingIndicator</span><span class="params">(<span class="keyword">boolean</span> active)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTasks</span><span class="params">(List&lt;Task&gt; tasks)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showAddTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTaskDetailsUi</span><span class="params">(String taskId)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTaskMarkedComplete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTaskMarkedActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showCompletedTasksCleared</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showLoadingTasksError</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showNoTasks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showActiveFilterLabel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showCompletedFilterLabel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showAllFilterLabel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showNoActiveTasks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showNoCompletedTasks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showSuccessfullySavedMessage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showFilteringPopUpMenu</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">result</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loadTasks</span><span class="params">(<span class="keyword">boolean</span> forceUpdate)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addNewTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">openTaskDetails</span><span class="params">(@NonNull Task requestedTask)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">completeTask</span><span class="params">(@NonNull Task completedTask)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">activateTask</span><span class="params">(@NonNull Task activeTask)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clearCompletedTasks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setFiltering</span><span class="params">(TasksFilterType requestType)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">TasksFilterType <span class="title">getFiltering</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>TasksActivity</strong></p><p>Activity 在项目中是一个全局的控制者，负责创建 view 以及 presenter 实例，并将二者联系起来。<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"> TasksFragment tasksFragment =</span><br><span class="line">         (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</span><br><span class="line"> <span class="keyword">if</span> (tasksFragment == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 创建 fragment</span></span><br><span class="line">     tasksFragment = TasksFragment.<span class="keyword">new</span><span class="type">Instance</span>();</span><br><span class="line">     ActivityUtils.addFragmentToActivity(</span><br><span class="line">             getSupportFragmentManager(), tasksFragment, R.id.contentFrame);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建 presenter，TasksPresenter是TasksContract.Presenter 的实现类</span></span><br><span class="line"><span class="comment">// 传入两个参数 </span></span><br><span class="line"><span class="comment">//1.TasksRepository实例，负责数据层  </span></span><br><span class="line"><span class="comment">//2.tasksFragment，是TasksContract.View的实现类，即view实例</span></span><br><span class="line"> mTasksPresenter = <span class="keyword">new</span> <span class="type">TasksPresenter</span>(</span><br><span class="line">         Injection.provideTasksRepository(getApplicationContext()), tasksFragment);</span><br></pre></td></tr></table></figure></p><p>其中，通过实例化<code>TasksPresenter</code>时，传入<code>tasksFragment</code>，使得在<code>TasksPresenter</code>中拥有view实例。同时，在实例化时初始化构造函数，调用了<code>setPresenter()</code>方法，使得view实例中拥有了presenter实例对象，使得两者联系起来。</p><p><code>TasksPresenter</code>构造函数如下所示：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TasksPresenter(<span class="meta">@NonNull</span> TasksRepository tasksRepository, <span class="meta">@NonNull</span> TasksContract.View tasksView) &#123;</span><br><span class="line">    mTasksRepository = checkNotNull(tasksRepository, <span class="string">"tasksRepository cannot be null"</span>);</span><br><span class="line">    mTasksView = checkNotNull(tasksView, <span class="string">"tasksView cannot be null!"</span>);</span><br><span class="line"></span><br><span class="line">    mTasksView.setPresenter(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>TasksFragment</strong></p><p>将Fragment作为view层的实现类，使得Activity作为一个全局控制类来创建对象，而Fragment作为view，两者各司其职。同时，Fragment比较灵活，能够方便的处理界面适配的问题。<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">TasksContract</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line">    ...........</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">TasksFragment <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TasksFragment();</span><br><span class="line">    &#125;</span><br><span class="line">    ...........</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mPresenter.start();</span><br><span class="line">    &#125;</span><br><span class="line">    ...........</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(@NonNull TasksContract.Presenter presenter)</span> </span>&#123;</span><br><span class="line">        mPresenter = checkNotNull(presenter);</span><br><span class="line">    &#125;</span><br><span class="line">    ...........</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">isAdded</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于 view 的实现TasksFragment，只挑一部分重要的方法来看。</p><ul><li><code>newInstance ()</code>方法，实例化TasksFragment对象。</li><li><code>setPresenter()</code>方法继承于父类，通过该方法，view 获得了 presenter 得实例，从而可以调用 presenter 代码来处理业务逻辑。</li><li>在<code>onResume()</code>中，调用了 presenter 得<code>start()</code>方法，获取数据并操作view界面的显示。</li><li><code>isActive()</code>方法，通过<code>isAdded()</code>判断对应Activity是否销毁。在Fragment在执行异步耗时操作后，如果调用Activity实例，应当先使用<code>isActive()</code>方法加以判断。</li></ul><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>通过对todo-mvp分析，再次了解学习了MVP。从google提供的例子中可以看出，MVP的实现较为简单，model、view和presenter各个职责明确，便于扩展维护。contract契约类的出现，使得model和presenter结构更加清晰明了。Activity和Fragment的配合，使得Activity职能更为简化，同时View的实现更加灵活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;已经使用了一段时间的MVP模式，今天再以google官方的安卓架构示例todo-mvp为例，再次学习MVP模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、MVP简介&quot;&gt;&lt;a href=&quot;#一、MVP简介&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://lrh1993.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue封装Swiper实现图片轮播</title>
    <link href="https://lrh1993.github.io/2018/02/06/Vue%E5%B0%81%E8%A3%85Swiper%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD/"/>
    <id>https://lrh1993.github.io/2018/02/06/Vue封装Swiper实现图片轮播/</id>
    <published>2018-02-06T07:29:21.000Z</published>
    <updated>2018-02-06T07:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>图片轮播是前端中经常需要实现的一个功能。最近学习Vue.js，就针对Swiper进行封装，实现一个简单的图片轮播组件。</p></blockquote><h2 id="一、Swiper"><a href="#一、Swiper" class="headerlink" title="一、Swiper"></a>一、Swiper</h2><p>在实现封装之前，先介绍一下Swiper。</p><ul><li><p>Swiper是纯Javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。</p></li><li><p>Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。</p></li><li><p>Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择。</p></li></ul><p>Swiper的应用场景广泛，实现效果很好，下面个这实际案例就是Swiper的典型应用场景。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-00cff6709a904b26.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>Swiper的具体使用教程及详细API，参考<a href="http://www.swiper.com.cn/" target="_blank" rel="noopener">Swiper中文网</a>。</p><h2 id="二、Vue组件"><a href="#二、Vue组件" class="headerlink" title="二、Vue组件"></a>二、Vue组件</h2><p>Vue组件设计初衷就是要配合使用的，提高维护性和复用性。而图片轮播正适合使用组件来完成，因此在介绍具体的实现之前，先介绍下关于Vue组件及组件通信。</p><p>Vue组件中最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。</p><p>它们之间必然需要相互通信：父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。然而，通过一个良好定义的接口来尽可能将父子组件解耦也是很重要的。这保证了每个组件的代码可以在相对隔离的环境中书写和理解，从而提高了其可维护性和复用性。</p><p>在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-bf27e8b63d03172a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="三、封装实现"><a href="#三、封装实现" class="headerlink" title="三、封装实现"></a>三、封装实现</h2><h3 id="1-引入Swiper"><a href="#1-引入Swiper" class="headerlink" title="1.引入Swiper"></a>1.引入Swiper</h3><p>首先，需要安装Swiper。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save swiper</span></span><br></pre></td></tr></table></figure></p><p>然后，要引用两个文件。<br><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Swiper from <span class="string">"swiper"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"swiper/dist/css/swiper.min.css"</span>;</span><br></pre></td></tr></table></figure></p><h3 id="2-HTML代码"><a href="#2-HTML代码" class="headerlink" title="2.HTML代码"></a>2.HTML代码</h3><p>在模板中设置轮播图的html布局。<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-container"</span> <span class="attr">:class</span>=<span class="string">"swipeid"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-wrapper"</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="comment">&lt;!-- 存放具体的轮播内容 --&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span> =<span class="string">"swiper-con"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="comment">&lt;!-- 分页器 --&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;'swiper-pagination':pagination&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>其中使用具名插槽，提高解耦，使得在父组件使用时，根据不同情况，设置不同的轮播内容。</p><p>另外需要设置分页器，即图片轮播中的页面指示器，常见的如小圆点，或者数字指示器。</p><h3 id="3-初始化Swiper"><a href="#3-初始化Swiper" class="headerlink" title="3.初始化Swiper"></a>3.初始化Swiper</h3><p>既然是对Swiper进行封装实现轮播图，前面也已经安装了Swiper，那么现在就需要初始化使用。</p><p>在初始化之前，根据Swiper用法的了解，先确定轮播组件需要的属性信息，然后通过父组件传递给封装的Swiper组件。</p><p>这时候就需要用到props。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">props</span>: &#123;</span><br><span class="line">    <span class="attribute">swipeid</span>: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">effect</span>: &#123;</span><br><span class="line">      <span class="attribute">type</span>: String,</span><br><span class="line">      default: <span class="string">"slide"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">loop</span>: &#123;</span><br><span class="line">      <span class="attribute">type</span>: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">direction</span>: &#123;</span><br><span class="line">      <span class="attribute">type</span>: String,</span><br><span class="line">      default: <span class="string">"horizontal"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">pagination</span>: &#123;</span><br><span class="line">      <span class="attribute">type</span>: Boolean,</span><br><span class="line">      default: true</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">paginationType</span>: &#123;</span><br><span class="line">      <span class="attribute">type</span>: String,</span><br><span class="line">      default: <span class="string">"bullets"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">autoPlay</span>: &#123;</span><br><span class="line">      <span class="attribute">type</span>: Number,</span><br><span class="line">      default: <span class="number">3000</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>下面逐一解释每个属性的含义。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>swiped</td><td>轮播容器class属性的类名。</td></tr><tr><td>effect</td><td>图片的 切换效果，默认为”slide”，还可设置为”fade”, “cube”, “coverflow”,”flip”，详情见<a href="http://www.swiper.com.cn/api/effects/193.html" target="_blank" rel="noopener">effect</a>。</td></tr><tr><td>loop</td><td>设置为true 则开启loop模式。loop模式：会在原本图片前后复制若干个图片并在合适的时候切换，让Swiper看起来是循环的，详情见<a href="http://www.swiper.com.cn/api/loop/22.html" target="_blank" rel="noopener">loop</a>。</td></tr><tr><td>direction</td><td>图片的滑动方向，可设置水平(horizontal)或垂直(vertical)，详情见<a href="http://www.swiper.com.cn/api/parameters/21.html" target="_blank" rel="noopener">direction</a>。</td></tr><tr><td>pagination</td><td>使用分页导航，详情见<a href="http://www.swiper.com.cn/api/pagination/362.html" target="_blank" rel="noopener">pagination</a>。</td></tr><tr><td>paginationType</td><td>分页器样式类型，可设置为”bullets”, “fraction”, “progressbar”, “custom”，详情见<a href="http://www.swiper.com.cn/api/pagination/299.html" target="_blank" rel="noopener">type</a>。</td></tr><tr><td>autoPlay</td><td>设置为true启动自动切换，并使用默认的切换设置，详情见<a href="http://www.swiper.com.cn/api/autoplay/16.html" target="_blank" rel="noopener">autoplay</a>。</td></tr></tbody></table><p>了解了上面每个属性的含义，下面就可以初始化Swiper，并设置具体的属性。</p><p>初始化Swiper时，需要传入两个参数。</p><ul><li>轮播容器的类名</li><li>代表图片轮播组件详细功能的对象</li></ul><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>.dom = new Swiper(<span class="string">"."</span> + that.swipeid, &#123;</span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    loop: that.loop,</span><br><span class="line">    <span class="comment">//分页器</span></span><br><span class="line">    pagination: &#123; </span><br><span class="line">      el: <span class="string">".swiper-pagination"</span>,</span><br><span class="line">      bulletClass : <span class="string">'swiper-pagination-bullet'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">    <span class="comment">//分页类型</span></span><br><span class="line">    paginationType: that.paginationType,</span><br><span class="line">    <span class="comment">//自动播放</span></span><br><span class="line">    autoPlay: that.autoPlay,</span><br><span class="line">    <span class="comment">//方向</span></span><br><span class="line">    direction: that.direction,</span><br><span class="line">    <span class="comment">//特效</span></span><br><span class="line">    effect: that.effect,</span><br><span class="line">    <span class="comment">//用户操作swiper之后，不禁止autoplay</span></span><br><span class="line">    disableOnInteraction: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//修改swiper自己或子元素时，自动初始化swiper</span></span><br><span class="line">    observer: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//修改swiper的父元素时，自动初始化swiper</span></span><br><span class="line">    observeParents: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、自定义轮播效果"><a href="#四、自定义轮播效果" class="headerlink" title="四、自定义轮播效果"></a>四、自定义轮播效果</h2><p>经过上面的步骤，轮播器就封装好了。我们可以自定义实现自己想要的轮播器效果。下面以知乎的API为例，实现图片轮播。</p><h3 id="1-HTML代码"><a href="#1-HTML代码" class="headerlink" title="1.HTML代码"></a>1.HTML代码</h3><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">m-swipe</span> <span class="attr">swipeid</span>=<span class="string">"swipe"</span> <span class="attr">ref</span>=<span class="string">"swiper"</span> <span class="attr">:autoPlay</span>=<span class="string">"3000"</span> <span class="attr">effect</span>=<span class="string">"slide"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"top in tops"</span> <span class="attr">:key</span>=<span class="string">"top.id"</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span> <span class="attr">slot</span>=<span class="string">"swiper-con"</span> &gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"top.image"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><span class="template-variable">&#123;&#123;top.title&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">m-swipe</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>首先要引用注册组件，这里就不详细写出。</p><p>其中<code>m-swipe</code>就是前面实现的图片轮播组件，而其中的子组件就是通过具名插槽插入的轮播内容。</p><h3 id="2-CSS代码"><a href="#2-CSS代码" class="headerlink" title="2.CSS代码"></a>2.CSS代码</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.swiper-container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.swiper-slide</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">8rem</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-class">.swiper-slide</span> &#123;</span><br><span class="line">  <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.4</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">background-color</span>: @blue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">transform</span>: translate(<span class="number">0</span>, -<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.5rem</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">5%</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">2.6rem</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">10px</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">    &amp;:before &#123;</span><br><span class="line">      <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">3rem</span>;</span><br><span class="line">      <span class="attribute">bottom</span>: -<span class="number">0.6rem</span>;</span><br><span class="line">      <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">display</span>: block;</span><br><span class="line">      <span class="attribute">position</span>: absolute;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">2px</span> solid @yellow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-pagination-bullet-active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-container-horizontal</span> &gt; <span class="selector-class">.swiper-pagination-bullets</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">95%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: right;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中<code>swiper-pagination-bullet-active</code>代表分页器中当前指示的小圆点的类名。<code>swiper-pagination-bullets</code>代表分页器的类名，详情见<a href="http://www.swiper.com.cn/api/pagination/79.html" target="_blank" rel="noopener">pagination分页器内元素的类名</a>。</p><p>关于网络请求数据展示的代码就不贴了，下面有源码地址。</p><h3 id="3-效果"><a href="#3-效果" class="headerlink" title="3.效果"></a>3.效果</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-929709345fdb3f4b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这只是一个简单的封装效果，想要实现更多的效果，可以通过Swiper中提供的更多功能来实现。</p><p><strong>Github地址：</strong> <a href="https://github.com/LRH1993/daily-zhihu/blob/master/src/components/swipe/swipe.vue" target="_blank" rel="noopener">图片轮播</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;图片轮播是前端中经常需要实现的一个功能。最近学习Vue.js，就针对Swiper进行封装，实现一个简单的图片轮播组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、Swiper&quot;&gt;&lt;a href=&quot;#一、Swiper&quot; class=&quot;h
      
    
    </summary>
    
      <category term="Vue" scheme="https://lrh1993.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>简单理解Vue中的nextTick</title>
    <link href="https://lrh1993.github.io/2018/01/30/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3Vue%E4%B8%AD%E7%9A%84nextTick/"/>
    <id>https://lrh1993.github.io/2018/01/30/简单理解Vue中的nextTick/</id>
    <published>2018-01-30T02:54:57.000Z</published>
    <updated>2018-01-30T03:08:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Vue中的<code>nextTick</code>涉及到Vue中DOM的异步更新，感觉很有意思，特意了解了一下。其中关于<code>nextTick</code>的源码涉及到不少知识，很多不太理解，暂且根据自己的一些感悟介绍下<code>nextTick</code>。</p></blockquote><h2 id="一、示例"><a href="#一、示例" class="headerlink" title="一、示例"></a>一、示例</h2><p>先来一个示例了解下关于Vue中的DOM更新以及<code>nextTick</code>的作用。</p><p><strong>模板</strong><br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> ref=<span class="string">"msgDiv"</span>&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> v-<span class="keyword">if</span>=<span class="string">"msg1"</span>&gt;Message got outside <span class="variable">$nextTick</span>: &#123;&#123;msg1&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> v-<span class="keyword">if</span>=<span class="string">"msg2"</span>&gt;Message got inside <span class="variable">$nextTick</span>: &#123;&#123;msg2&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> v-<span class="keyword">if</span>=<span class="string">"msg3"</span>&gt;Message got outside <span class="variable">$nextTick</span>: &#123;&#123;msg3&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;<span class="selector-tag">button</span> @click=<span class="string">"changeMsg"</span>&gt;</span><br><span class="line">    Change the Message</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><strong>Vue实例</strong><br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">'.app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">'Hello Vue.'</span>,</span><br><span class="line">    msg1: <span class="string">''</span>,</span><br><span class="line">    msg2: <span class="string">''</span>,</span><br><span class="line">    msg3: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeMsg() &#123;</span><br><span class="line">      this<span class="selector-class">.msg</span> = <span class="string">"Hello world."</span></span><br><span class="line">      this<span class="selector-class">.msg1</span> = this.<span class="variable">$refs</span><span class="selector-class">.msgDiv</span><span class="selector-class">.innerHTML</span></span><br><span class="line">      this.<span class="variable">$nextTick</span>(() =&gt; &#123;</span><br><span class="line">        this<span class="selector-class">.msg2</span> = this.<span class="variable">$refs</span><span class="selector-class">.msgDiv</span><span class="selector-class">.innerHTML</span></span><br><span class="line">      &#125;)</span><br><span class="line">      this<span class="selector-class">.msg3</span> = this.<span class="variable">$refs</span><span class="selector-class">.msgDiv</span><span class="selector-class">.innerHTML</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>点击前</strong><br><img src="http://upload-images.jianshu.io/upload_images/3985563-b6bb266285e8d232.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>点击后</strong><br><img src="http://upload-images.jianshu.io/upload_images/3985563-f49bff3190724514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从图中可以得知：msg1和msg3显示的内容还是变换之前的，而msg2显示的内容是变换之后的。其根本原因是因为Vue中DOM更新是异步的（详细解释在后面）。</p><h2 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h2><p>下面了解下<code>nextTick</code>的主要应用的场景及原因。</p><ul><li>在Vue生命周期的<code>created()</code>钩子函数进行的DOM操作一定要放在<code>Vue.nextTick()</code>的回调函数中</li></ul><p>在<code>created()</code>钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进<code>Vue.nextTick()</code>的回调函数中。与之对应的就是<code>mounted()</code>钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。</p><ul><li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进<code>Vue.nextTick()</code>的回调函数中。</li></ul><p>具体原因在Vue的官方文档中详细解释：</p><blockquote><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和<code>MessageChannel</code>，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code>代替。</p></blockquote><blockquote><p>例如，当你设置<code>vm.someData = &#39;new value&#39;</code>，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用<code>Vue.nextTick(callback)</code> 。这样回调函数在 DOM 更新完成后就会调用。</p></blockquote><h2 id="三、nextTick源码浅析"><a href="#三、nextTick源码浅析" class="headerlink" title="三、nextTick源码浅析"></a>三、<code>nextTick</code>源码浅析</h2><p><strong>作用</strong></p><p><code>Vue.nextTick</code>用于延迟执行一段代码，它接受2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回<code>promise</code>对象。</p><p><strong>源码</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defer a task to execute it asynchronously.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nextTick = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> callbacks = []</span><br><span class="line">  <span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">    callbacks.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">      copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line">  <span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line">  <span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line">  <span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line">  <span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line">  <span class="comment">// Promise is available, we will use it:</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    <span class="keyword">var</span> logError = <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="built_in">console</span>.error(err) &#125;</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      p.then(nextTickHandler).catch(logError)</span><br><span class="line">      <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">      <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">      <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">      <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">      <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">      <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">    isNative(MutationObserver) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">  )) &#123;</span><br><span class="line">    <span class="comment">// use MutationObserver where native Promise is not available,</span></span><br><span class="line">    <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(nextTickHandler)</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">    observer.observe(textNode, &#123;</span><br><span class="line">      characterData: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">      textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// fallback to setTimeout</span></span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(nextTickHandler, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">queueNextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _resolve</span><br><span class="line">    callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cb.call(ctx)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">        _resolve(ctx)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">      pending = <span class="literal">true</span></span><br><span class="line">      timerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        _resolve = resolve</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>首先，先了解<code>nextTick</code>中定义的三个重要变量。</p><ul><li><code>callbacks</code></li></ul><p>用来存储所有需要执行的回调函数</p><ul><li><code>pending</code></li></ul><p>用来标志是否正在执行回调函数</p><ul><li><code>timerFunc</code></li></ul><p>用来触发执行回调函数</p><p>接下来，了解<code>nextTickHandler()</code>函数。<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> <span class="params">()</span> &#123;</span></span><br><span class="line">    pending = false</span><br><span class="line">    const copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">    callbacks.<span class="built_in">length</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (let <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; copies.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">      copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个函数用来执行<code>callbacks</code>里存储的所有回调函数。</p><p>接下来是将触发方式赋值给<code>timerFunc</code>。</p><ul><li>先判断是否原生支持promise，如果支持，则利用promise来触发执行回调函数；</li><li>否则，如果支持MutationObserver，则实例化一个观察者对象，观察文本节点发生变化时，触发执行所有回调函数。</li><li>如果都不支持，则利用setTimeout设置延时为0。</li></ul><p>最后是<code>queueNextTick</code>函数。因为<code>nextTick</code>是一个即时函数，所以<code>queueNextTick</code>函数是返回的函数，接受用户传入的参数，用来往callbacks里存入回调函数。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-a9e7d48417e3900f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上图是整个执行流程，关键在于<code>timeFunc()</code>，该函数起到延迟执行的作用。</p><p>从上面的介绍，可以得知<code>timeFunc()</code>一共有三种实现方式。</p><ul><li><code>Promise</code></li><li><code>MutationObserver</code></li><li><code>setTimeout</code></li></ul><p>其中<code>Promise</code>和<code>setTimeout</code>很好理解，是一个异步任务，会在同步任务以及更新DOM的异步任务之后回调具体函数。</p><p>下面着重介绍一下<code>MutationObserver</code>。</p><p><code>MutationObserver</code>是HTML5中的新API，是个用来监视DOM变动的接口。他能监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等等。<br>调用过程很简单，但是有点不太寻常：你需要先给他绑回调：<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mo = <span class="keyword">new</span> <span class="type">MutationObserver</span>(callback)</span><br></pre></td></tr></table></figure></p><p>通过给<code>MutationObserver</code>的构造函数传入一个回调，能得到一个<code>MutationObserver</code>实例，这个回调就会在<code>MutationObserver</code>实例监听到变动时触发。</p><p>这个时候你只是给<code>MutationObserver</code>实例绑定好了回调，他具体监听哪个DOM、监听节点删除还是监听属性修改，还没有设置。而调用他的<code>observer</code>方法就可以完成这一步:<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> domTarget = 你想要监听的dom节点</span><br><span class="line">mo.observe(domTarget, &#123;</span><br><span class="line">      characterData: <span class="literal">true</span> <span class="comment">//说明监听文本内容的修改。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-3d5f3707101ce1a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在<code>nextTick</code>中 <code>MutationObserver</code>的作用就如上图所示。在监听到DOM更新后，调用回调函数。</p><p>其实使用 <code>MutationObserver</code>的原因就是 <code>nextTick</code>想要一个异步API，用来在当前的同步代码执行完毕后，执行我想执行的异步回调，包括<code>Promise</code>和 <code>setTimeout</code>都是基于这个原因。其中深入还涉及到<code>microtask</code>等内容，暂时不理解，就不深入介绍了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Vue中的&lt;code&gt;nextTick&lt;/code&gt;涉及到Vue中DOM的异步更新，感觉很有意思，特意了解了一下。其中关于&lt;code&gt;nextTick&lt;/code&gt;的源码涉及到不少知识，很多不太理解，暂且根据自己的一些感悟介绍下&lt;code&gt;next
      
    
    </summary>
    
      <category term="Vue" scheme="https://lrh1993.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript异步机制详解</title>
    <link href="https://lrh1993.github.io/2018/01/26/JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lrh1993.github.io/2018/01/26/JavaScript异步机制详解/</id>
    <published>2018-01-26T07:31:26.000Z</published>
    <updated>2018-01-26T07:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步问题。</p></blockquote><h2 id="一、同步与异步"><a href="#一、同步与异步" class="headerlink" title="一、同步与异步"></a>一、同步与异步</h2><p>在介绍JavaScript的异步机制之前，首先介绍一下：什么是同步？什么是异步？<br><img src="http://upload-images.jianshu.io/upload_images/3985563-bbc80847ea8e5755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>如果在函数返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。<br>如下所示：<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在函数返回时，获得了预期值，即2的平方根</span></span><br><span class="line">Math.<span class="built_in">sqrt</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//在函数返回时，获得了预期的效果，即在控制台上打印了'hello'</span></span><br><span class="line">console.<span class="built_in">log</span>('hello');</span><br></pre></td></tr></table></figure></p><p>上面两个函数就是同步的。</p><p><strong>如果函数是同步的，即使调用函数执行的任务比较耗时，也会一直等待直到得到预期结果。</strong></p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。<br>如下所示：<br><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">fs.readFile(<span class="string">'hello.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//网络请求</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = xxx; <span class="comment">// 添加回调函数</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="built_in">url</span>);</span><br><span class="line">xhr.send(); <span class="comment">// 发起函数</span></span><br></pre></td></tr></table></figure></p><p>上述示例中读取文件函数 <code>readFile</code>和网络请求的发起函数  <code>send</code>都将执行耗时操作，虽然函数会立即返回，但是不能立刻获取预期的结果，因为耗时操作交给其他线程执行，暂时获取不到预期结果（后面介绍）。而在JavaScript中通过回调函数 <code>function(err, data) {    console.log(data);}</code>和 <code>onreadystatechange</code>   ，在耗时操作执行完成后把相应的结果信息传递给回调函数，通知执行JavaScript代码的线程执行回调。</p><p><strong>如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。</strong></p><h2 id="二、单线程与多线程"><a href="#二、单线程与多线程" class="headerlink" title="二、单线程与多线程"></a>二、单线程与多线程</h2><p><img src="http://upload-images.jianshu.io/upload_images/3985563-11b3608aaa49f7b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在上面介绍异步的过程中就可能会纳闷：既然JavaScript是单线程，怎么还存在异步，那些耗时操作到底交给谁去执行了？</p><p>JavaScript其实就是一门语言，说是单线程还是多线程得结合具体运行环境。JS的运行通常是在浏览器中进行的，具体由JS引擎去解析和运行。下面我们来具体了解一下浏览器。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>目前最为流行的浏览器为：Chrome，IE，Safari，FireFox，Opera。浏览器的内核是多线程的。</p><p>一个浏览器通常由以下几个常驻的线程：</p><ul><li>渲染引擎线程：顾名思义，该线程负责页面的渲染</li><li>JS引擎线程：负责JS的解析和执行</li><li>定时触发器线程：处理定时事件，比如setTimeout, setInterval</li><li>事件触发线程：处理DOM事件</li><li>异步http请求线程：处理http请求</li></ul><p>需要注意的是，渲染线程和JS引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS引擎线程会被挂起。因为JS可以操作DOM，若在渲染中JS处理了DOM，浏览器可能就不知所措了。</p><h3 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h3><p>通常讲到浏览器的时候，我们会说到两个引擎：渲染引擎和JS引擎。渲染引擎就是如何渲染页面，Chrome／Safari／Opera用的是Webkit引擎，IE用的是Trident引擎，FireFox用的是Gecko引擎。不同的引擎对同一个样式的实现不一致，就导致了经常被人诟病的浏览器样式兼容性问题。这里我们不做具体讨论。</p><p>JS引擎可以说是JS虚拟机，负责JS代码的解析和执行。通常包括以下几个步骤：</p><ul><li>词法分析：将源代码分解为有意义的分词</li><li>语法分析：用语法分析器将分词解析成语法树</li><li>代码生成：生成机器能运行的代码</li><li>代码执行</li></ul><p>不同浏览器的JS引擎也各不相同，Chrome用的是V8，FireFox用的是SpiderMonkey，Safari用的是JavaScriptCore，IE用的是Chakra。</p><p>之所以说JavaScript是单线程，就是因为浏览器在运行时只开启了一个JS引擎线程来解析和执行JS。那为什么只有一个引擎呢？如果同时有两个线程去操作DOM，浏览器是不是又要不知所措了。</p><p><strong>所以，虽然JavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。</strong></p><h2 id="三、消息队列与事件循环"><a href="#三、消息队列与事件循环" class="headerlink" title="三、消息队列与事件循环"></a>三、消息队列与事件循环</h2><p>通过以上了解，可以知道其实JavaScript也是通过JS引擎线程与浏览器中其他线程交互协作实现异步。但是回调函数具体何时加入到JS引擎线程中执行？执行顺序是怎么样的？</p><p>这一切的解释就需要继续了解消息队列和事件循环。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-b1682e665abed777.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如上图所示，左边的栈存储的是同步任务，就是那些能立即执行、不耗时的任务，如变量和函数的初始化、事件的绑定等等那些不需要回调函数的操作都可归为这一类。</p><p>右边的堆用来存储声明的变量、对象。下面的队列就是消息队列，一旦某个异步任务有了响应就会被推入队列中。如用户的点击事件、浏览器收到服务的响应和setTimeout中待执行的事件，每个异步任务都和回调函数相关联。</p><p>JS引擎线程用来执行栈中的同步任务，当所有同步任务执行完毕后，栈被清空，然后读取消息队列中的一个待处理任务，并把相关回调函数压入栈中，单线程开始执行新的同步任务。</p><p>JS引擎线程从消息队列中读取任务是不断循环的，每次栈被清空后，都会在消息队列中读取新的任务，如果没有新的任务，就会等待，直到有新的任务，这就叫事件循环。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-4a3596c01cbef3bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上图以AJAX异步请求为例，发起异步任务后，由AJAX线程执行耗时的异步操作，而JS引擎线程继续执行堆中的其他同步任务，直到堆中的所有异步任务执行完毕。然后，从消息队列中依次按照顺序取出消息作为一个同步任务在JS引擎线程中执行，那么AJAX的回调函数就会在某一时刻被调用执行。</p><h2 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h2><p>引用一篇文章中提到的考察JavaScript异步机制的面试题来具体介绍。</p><blockquote><p>执行下面这段代码，执行后，在 5s 内点击两下，过一段时间（&gt;5s）后，再点击两下，整个过程的输出结果是什么？</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer a'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer b'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitFiveSeconds</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">    <span class="keyword">while</span>(((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - now) &lt; <span class="number">5000</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finished waiting'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'click begin'</span>);</span><br><span class="line">waitFiveSeconds();</span><br></pre></td></tr></table></figure><p>要想了解上述代码的输出结果，首先介绍下定时器。</p><p><code>setTimeout</code>的作用是在间隔一定的时间后，将回调函数插入消息队列中，等栈中的同步任务都执行完毕后，再执行。因为栈中的同步任务也会耗时，<strong>所以间隔的时间一般会大于等于指定的时间</strong>。</p><p><code>setTimeout(fn, 0)</code>的意思是，将回调函数fn立刻插入消息队列，等待执行，而不是立即执行。看一个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a"</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b"</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">b</span>  a</span><br></pre></td></tr></table></figure><p>打印结果表明回调函数并没有立刻执行，而是等待栈中的任务执行完毕后才执行的。栈中的任务执行多久，它就得等多久。</p><p>理解了定时器的作用，那么对于输出结果就容易得出了。</p><p>首先，先执行同步任务。其中<code>waitFiveSeconds</code>是耗时操作，持续执行长达5s。<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">click begin</span><br><span class="line">finished waiting</span><br></pre></td></tr></table></figure></p><p>然后，在JS引擎线程执行的时候，’timer a’对应的定时器产生的回调、 ‘timer b’对应的定时器产生的回调和两次 click 对应的回调被先后放入消息队列。由于JS引擎线程空闲后，会<strong>先查看是否有事件可执行</strong>，接着再处理其他异步任务。因此会产生 下面的输出顺序。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">click</span></span><br><span class="line"><span class="built_in">click</span></span><br><span class="line">timer a</span><br><span class="line">timer b</span><br></pre></td></tr></table></figure></p><p>最后，5s 后的两次 click 事件被放入消息队列，由于此时JS引擎线程空闲，便被立即执行了。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">click</span></span><br><span class="line"><span class="built_in">click</span></span><br></pre></td></tr></table></figure></p><p><strong>参考文章</strong><br> <a href="https://segmentfault.com/a/1190000004322358" target="_blank" rel="noopener">JavaScript：彻底理解同步、异步和事件循环(Event Loop)</a><br><a href="http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/" title="【转向Javascript系列】从setTimeout说事件循环模型" target="_blank" rel="noopener">从setTimeout说事件循环模型</a><br><a href="https://github.com/pramper/Blog/issues/4" target="_blank" rel="noopener">JavaScript单线程和异步机制</a><br><a href="https://github.com/huangtengfei/blog/issues/15" target="_blank" rel="noopener">JavaScript的单线程机制</a><br><a href="https://zhuanlan.zhihu.com/p/27035708" target="_blank" rel="noopener">JavaScript单线程异步的背后——事件循环机制</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学习JavaScript的时候了解到JavaScript是单线程的，刚开始很疑惑，单线程怎么处理网络请求、文件读写等耗时操作呢？效率岂不是会很低？随着对这方面内容的了解和深入，知道了其中的奥秘。本篇文章就主要讲解一下JavaScript怎么处理异步
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://lrh1993.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS3的动画属性</title>
    <link href="https://lrh1993.github.io/2017/12/26/CSS3%E7%9A%84%E5%8A%A8%E7%94%BB%E5%B1%9E%E6%80%A7/"/>
    <id>https://lrh1993.github.io/2017/12/26/CSS3的动画属性/</id>
    <published>2017-12-26T13:10:31.000Z</published>
    <updated>2017-12-27T09:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>transition、animation和transform是CSS3中三个制作动画的重要属性，本篇文章主要对其进行学习了解。</p></blockquote><h2 id="一、transition"><a href="#一、transition" class="headerlink" title="一、transition"></a>一、transition</h2><p><code>transition</code>允许css的属性值在一定的时间区间内平滑地<strong>过渡</strong>。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值。</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">transition ：transition-property |<span class="type">| transition</span>-duration |<span class="type">| transition</span>-timing-function |<span class="type">| transition</span>-delay;</span><br></pre></td></tr></table></figure><p><code>transition</code>主要包含四个属性值：执行变换的属性：<code>transition-property</code>，变换延续的时间：<code>transition-duration</code>，在延续时间段，变换的速率变化：<code>transition-timing-function</code>，变换延迟时间：<code>transition-delay</code>。</p><h3 id="1-transition-property"><a href="#1-transition-property" class="headerlink" title="1. transition-property"></a>1. transition-property</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">transition-<span class="keyword">property</span><span class="title"></span>: none || all || <span class="keyword">property</span><span class="title"></span>;</span><br></pre></td></tr></table></figure><p><code>transition-property</code>是用来指定当元素其中一个属性改变时执行<code>transition</code>效果。</p><p>none: 没有属性会获得过渡效果；</p><p>all: 所有属性都将获得过渡效果,<strong>也是其默认值</strong>；</p><p>property: 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。</p><h3 id="2-transition-duration"><a href="#2-transition-duration" class="headerlink" title="2. transition-duration"></a>2. transition-duration</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition-duration</span>: time;</span><br></pre></td></tr></table></figure><p><code>transition-duration</code>是用来指定元素 转换过程的持续时间，取值time为数值，单位为s（秒）或者ms(毫秒)，其默认值是0，也就是变换时是即时的。</p><h3 id="3-transition-timing-function"><a href="#3-transition-timing-function" class="headerlink" title="3. transition-timing-function"></a>3. transition-timing-function</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">transition-timing-function: linear |<span class="type">| ease</span> |<span class="type">| ease</span>-<span class="built_in">in</span> |<span class="type">| ease</span>-out |<span class="type">| ease</span>-<span class="built_in">in</span>-out |<span class="type">| cubic</span>-</span><br><span class="line">bezier(n,n,n,n);</span><br></pre></td></tr></table></figure><p>以上具体取值含义如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>linear</td><td>规定以相同速度开始至结束的过渡效果。</td></tr><tr><td>ease</td><td>规定慢速开始，然后变快，然后慢速结束的过渡效果。</td></tr><tr><td>ease-in</td><td>规定以慢速开始的过渡效果。</td></tr><tr><td>ease-out</td><td>规定以慢速结束的过渡效果。</td></tr><tr><td>ease-in-out</td><td>规定以慢速开始和结束的过渡效果。</td></tr><tr><td>cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td>在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</td></tr></tbody></table><h3 id="4-transition-delay"><a href="#4-transition-delay" class="headerlink" title="4. transition-delay"></a>4. transition-delay</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">transition-<span class="built_in">delay</span>: <span class="built_in">time</span>;</span><br></pre></td></tr></table></figure><p><code>transition-delay</code>是用来指定一个动画开始执行的时间，也就是说当改变元素属性值后多长时间开始执行<code>transition</code>效果，其取值time为数值，单位为s（秒）或者ms(毫秒)， 默认大小是”0”，也就是变换立即执行，没有延迟。</p><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><p>html代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#cd4a48</span>;</span><br><span class="line">        <span class="attribute">-webkit-transition</span>: width, height <span class="number">2s</span> ease;</span><br><span class="line">        <span class="attribute">-moz-transition</span>: width, height <span class="number">2s</span> ease;</span><br><span class="line">        <span class="attribute">-ms-transition</span>: width, height <span class="number">2s</span> ease;</span><br><span class="line">        <span class="attribute">-o-transition</span>: width, height <span class="number">2s</span> ease;</span><br><span class="line">        <span class="attribute">transition</span>: width, height <span class="number">2s</span> ease;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.one</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-af0098558fc18cb5.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul><li>不是所有的CSS属性都支持<code>transition</code>，完整的列表查看<a href="http://oli.jp/2010/css-animatable-properties/" target="_blank" rel="noopener">这里</a>，以及具体的<a href="http://leaverou.github.io/animatable/" target="_blank" rel="noopener">效果</a>。</li><li><code>transition</code>需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态。比如，height从0px变化到100px，<code>transition</code>可以算出中间状态。但是，<code>transition</code>没法算出0px到auto的中间状态，也就是说，如果开始或结束的设置是height: auto，那么就不会产生动画效果。</li><li><code>transition</code>需要事件触发，所以没法在网页加载时自动发生。</li><li><code>transition</code>是一次性的，不能重复发生，除非一再触发。</li></ul><h2 id="二、animation"><a href="#二、animation" class="headerlink" title="二、animation"></a>二、animation</h2><p>不同于<code>transition</code>只能定义首尾两个状态，<code>animation</code>可以定义任意多的关键帧，因而能实现更复杂的动画效果。</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">animation</span>: <span class="built_in">animation</span>-name || <span class="built_in">animation</span>-duration || <span class="built_in">animation</span>-timing-function || <span class="built_in">animation</span>-<span class="built_in">delay</span> || <span class="built_in">animation</span>-iteration-count || <span class="built_in">animation</span>-direction</span><br></pre></td></tr></table></figure><p><code>animation</code>主要包含六个属性，具体含义如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><em>animation-name</em></td><td>规定需要绑定到选择器的 keyframe 名称。。</td></tr><tr><td><em>animation-duration</em></td><td>规定完成动画所花费的时间，以秒或毫秒计。</td></tr><tr><td><em>animation-timing-function</em></td><td>规定动画的速度曲线。</td></tr><tr><td><em>animation-delay</em></td><td>规定在动画开始之前的延迟，默认值为0。</td></tr><tr><td><em>animation-iteration-count</em></td><td>规定动画应该播放的次数，默认值为1。</td></tr><tr><td><em>animation-direction</em></td><td>规定是否应该轮流反向播放动画，默认值是正向。</td></tr></tbody></table><h3 id="1-keyframe"><a href="#1-keyframe" class="headerlink" title="1. keyframe"></a>1. keyframe</h3><p>在介绍<code>animation</code>具体使用之前，要先介绍keyframe。</p><p><code>@keyframes</code> 让开发者通过指定动画中特定时间点必须展现的关键帧样式（或者说停留点）来控制CSS动画的中间环节。这让开发者能够控制动画中的更多细节而不是全部让浏览器自动处理。</p><p>要使用关键帧, 先创建一个带名称的<code>@keyframes</code>规则，以便后续使用 <code>animation-name</code>这个属性来调用指定的<code>@keyframes</code>. 每个<code>@keyframes</code> 规则包含多个关键帧，也就是一段样式块语句，每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式。</p><p>关键帧的编写顺序没有要求，最后只会根据百分比按由小到大的顺序触发。</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">@keyframes <span class="class">animationname </span>&#123;keyframes-<span class="class">selector </span>&#123;css-styles;&#125;&#125;</span><br></pre></td></tr></table></figure><p>具体含义如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><em>animationname</em></td><td>必需。定义动画的名称。</td></tr><tr><td><em>keyframes-selector</em></td><td>必需。动画时长的百分比。合法的值：0-100%from（与 0% 相同）to（与 100% 相同）</td></tr><tr><td><em>css-styles</em></td><td>必需。一个或多个合法的 CSS 样式属性。</td></tr></tbody></table><p>示例：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> identifier &#123;</span><br><span class="line">  0% &#123; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0px</span>&#125;</span><br><span class="line">  50% &#123; <span class="attribute">top</span>: <span class="number">30px</span>; <span class="attribute">left</span>: <span class="number">20px</span>; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">30px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p>html代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#cd4a48</span>;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">animation</span>: moveHover <span class="number">5s</span> ease-in-out <span class="number">0.2s</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @<span class="keyword">keyframes</span> moveHover &#123;</span><br><span class="line">        0% &#123;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">            <span class="attribute">background</span>: <span class="number">#cd4a48</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        50% &#123;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">background</span>:<span class="number">#A48992</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        100% &#123;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">350px</span>;</span><br><span class="line">            <span class="attribute">left</span>:<span class="number">350px</span>;</span><br><span class="line">            <span class="attribute">background</span>: <span class="number">#FFB89A</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-914eacab4466fe8b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="3-其他属性"><a href="#3-其他属性" class="headerlink" title="3. 其他属性"></a>3. 其他属性</h3><p>除了上述主要用到的六个属性外，还要额外介绍两个属性。</p><p><strong>animation-fill-mode</strong></p><p>动画结束以后，会立即从结束状态跳回到起始状态。如果想让动画保持在结束状态，需要使用<code>animation-fill-mode</code>属性。</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">animation</span>-<span class="meta">fill</span>-mode: none <span class="title">||</span> <span class="keyword">backwards </span><span class="title">||</span> <span class="keyword">both</span></span><br></pre></td></tr></table></figure><ul><li>none：默认值，回到动画没开始时的状态。</li><li>forwards：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。</li><li>backwards：在 <code>animation-delay</code>所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。</li><li>both: 根据<code>animation-direction</code>轮流应用forwards和backwards规则。</li></ul><p><strong>animation-play-state</strong></p><p>有时，动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态。</p><p>如果想让动画保持突然终止时的状态，就要使用<code>animation-play-state</code>属性。</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">animation-play-state:running <span class="string">|| paused</span></span><br></pre></td></tr></table></figure><p><code>animation-play-state</code>主要是用来控制元素动画的播放状态。其主要有两个值，running和paused其中running为默认值。通过paused将正在播放的动画停下了，通过running将暂停的动画重新播放，这个属性目前很少内核支持。</p><h2 id="三、transform"><a href="#三、transform" class="headerlink" title="三、transform"></a>三、transform</h2><p><code>transform</code>就是变形，主要包括<strong>旋转rotate</strong>、<strong>扭曲skew</strong>、<strong>缩放scale</strong>和<strong>移动translate</strong>以及<strong>矩阵变形matrix</strong>。</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span>: none || <span class="built_in">transform</span>-<span class="built_in">functions</span></span><br></pre></td></tr></table></figure><p>none:表示不进么变换；transform-function表示一个或多个变换函数，以空格分开；换句话说就是我们同时对一个元素进行transform的多种属性操作，例如rotate、scale、translate三种。</p><p>主要的transform-function变换函数如下：</p><h3 id="1-translate"><a href="#1-translate" class="headerlink" title="1. translate"></a>1. translate</h3><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>translate(<em>x</em>,<em>y</em>)</td><td>定义 2D 转换。</td></tr><tr><td>translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td>定义 3D 转换。</td></tr><tr><td>translateX(<em>x</em>)</td><td>定义转换，只是用 X 轴的值。</td></tr><tr><td>translateY(<em>y</em>)</td><td>定义转换，只是用 Y 轴的值。</td></tr><tr><td>translateZ(<em>z</em>)</td><td>定义 3D 转换，只是用 Z 轴的值。</td></tr></tbody></table><h3 id="2-scale"><a href="#2-scale" class="headerlink" title="2. scale"></a>2. scale</h3><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>scale(<em>x</em>,<em>y</em>)</td><td>定义 2D 缩放转换。</td></tr><tr><td>scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td>定义 3D 缩放转换。</td></tr><tr><td>scaleX(<em>x</em>)</td><td>通过设置 X 轴的值来定义缩放转换。</td></tr><tr><td>scaleY(<em>y</em>)</td><td>通过设置 Y 轴的值来定义缩放转换。</td></tr><tr><td>scaleZ(<em>z</em>)</td><td>通过设置 Z 轴的值来定义 3D 缩放转换。</td></tr></tbody></table><h3 id="3-rotate"><a href="#3-rotate" class="headerlink" title="3. rotate"></a>3. rotate</h3><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>rotate(<em>angle</em>)</td><td>定义 2D 旋转，在参数中规定角度。</td></tr><tr><td>rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td><td>定义 3D 旋转。</td></tr><tr><td>rotateX(<em>angle</em>)</td><td>定义沿着 X 轴的 3D 旋转。</td></tr><tr><td>rotateY(<em>angle</em>)</td><td>定义沿着 Y 轴的 3D 旋转。</td></tr><tr><td>rotateZ(<em>angle</em>)</td><td>定义沿着 Z 轴的 3D 旋转。</td></tr></tbody></table><h3 id="4-skew"><a href="#4-skew" class="headerlink" title="4. skew"></a>4. skew</h3><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>skew(<em>x-angle</em>,<em>y-angle</em>)</td><td>定义沿着 X 和 Y 轴的 2D 倾斜转换。</td></tr><tr><td>skewX(<em>angle</em>)</td><td>定义沿着 X 轴的 2D 倾斜转换。</td></tr><tr><td>skewY(<em>angle</em>)</td><td>定义沿着 Y 轴的 2D 倾斜转换。</td></tr></tbody></table><h3 id="5-transform-origin"><a href="#5-transform-origin" class="headerlink" title="5. transform-origin"></a>5. transform-origin</h3><p>以上变化的默认参照点是元素的中心点，不过可以通过<code>transform-origin</code>设置元素的参照点。</p><figure class="highlight tp"><table><tr><td class="code"><pre><span class="line">transform-origin: <span class="keyword">X</span> || <span class="keyword">Y</span> || <span class="keyword">Z</span></span><br></pre></td></tr></table></figure><p>其中X，Y，Z对应三维坐标，X，Y，Z的值可以是em，px。此外，X，Y可以是百分值，其中X也可以是字符参数值left，center，right。Y和X一样除了百分值外还可以设置字符值top，center，bottom。</p><p>具体示例就不再写了，情况比较多，实现起来也比较简单。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>以上是关于CSS3中制作动画的三个属性，内容比较基础，不过却很实用。仅仅只需要CSS，即可实现一些较为简单的动画效果，省去了复杂的js代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;transition、animation和transform是CSS3中三个制作动画的重要属性，本篇文章主要对其进行学习了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、transition&quot;&gt;&lt;a href=&quot;#一、transiti
      
    
    </summary>
    
      <category term="CSS" scheme="https://lrh1993.github.io/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS Flexbox详解</title>
    <link href="https://lrh1993.github.io/2017/12/14/CSS-Flexbox%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lrh1993.github.io/2017/12/14/CSS-Flexbox详解/</id>
    <published>2017-12-14T12:31:31.000Z</published>
    <updated>2017-12-14T12:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Flexbox是一个强大而灵活的布局，本篇文章主要对其进行学习了解。</p></blockquote><h2 id="一、Flexbox简介"><a href="#一、Flexbox简介" class="headerlink" title="一、Flexbox简介"></a>一、Flexbox简介</h2><p>Flexbox布局（Flexible Box)模块旨在提供一个更加有效的方式制定、调整和分布一个容器里的项目布局，即使他们的大小是未知或者是动态的。简单的理解，就是可以自动调整，计算元素在容器空间中的大小，并进行有效合理的布局。</p><p>Flexbox布局中有两个重要的概念：<strong>Flex容器和Flex项目</strong>。</p><p>Flex容器包含多个Flex项目，通过对Flex容器和Flex项目的具体属性进行设置，可以达到各种各样灵活的布局样式。</p><h3 id="Flexbox使用"><a href="#Flexbox使用" class="headerlink" title="Flexbox使用"></a>Flexbox使用</h3><p>Flexbox的使用非常简单，只需要对Flex容器设置<code>display:flex</code>或者<code>display:inline-flex</code>，就可以具体操作使用Flexbox布局了。</p><p>下面以具体示例演示：</p><p>html代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">20px</span> auto;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.wrap</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#a448cf</span>;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">80%</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">80%</span>  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.wrap</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">150px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">150px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#c75a5a</span>;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3985563-106f6367df1bc35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="二、Flex容器"><a href="#二、Flex容器" class="headerlink" title="二、Flex容器"></a>二、Flex容器</h2><p>首先介绍下Flex容器的具体属性以及具体的使用方式。</p><table><thead><tr><th>属性</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>flex-direction</td><td>row 或 column  或 row-reverse 或  column-reverse</td><td>控制Flex项目沿着主轴（Main Axis）的排列方向</td></tr><tr><td>flex-wrap</td><td>wrap 或  nowrap  或 wrap-reverse</td><td>控制Flex项目是否换行显示</td></tr><tr><td>flex-flow</td><td>row wrap 或 row nowrap  或 column wrap    或   column nowrap 等</td><td>flex-direction和flex-wrap两个属性的组合速记属性</td></tr><tr><td>justify-content</td><td>flex-start 或  flex-end  或 center  或 space-between 或  space-around</td><td>控制 Flex项目在Main-Axis上的对齐方式</td></tr><tr><td>align-items</td><td>flex-start 或  flex-end 或  center  或 stretch  或 baseline</td><td>控制Flex项目在<strong>Cross-Axis</strong>对齐方式</td></tr><tr><td>align-content</td><td>flex-start 或  flex-end  或 center  或 stretch</td><td>用于多行的Flex容器，控制Flex项目在<strong>Cross-Axis</strong>对齐方式</td></tr></tbody></table><h3 id="1-flex-direction"><a href="#1-flex-direction" class="headerlink" title="1. flex-direction"></a>1. flex-direction</h3><p><code>flex-direction</code>属性控制Flex项目沿着主轴（Main Axis）的排列方向，可以是行（水平）、列（垂直）或者行和列的反向。</p><p>默认情况下<code>flex-direction</code>的属性值是<code>row</code>,具体排列方式如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-779229b0e7a96d4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>但是当<code>flex-direction</code>的属性值是<code>column</code>，对应的主轴就应该垂直向下。</p><p>具体应用示例如下：<br><img src="http://upload-images.jianshu.io/upload_images/3985563-87680b7f519b18d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2-flex-wrap"><a href="#2-flex-wrap" class="headerlink" title="2. flex-wrap"></a>2. flex-wrap</h3><p><code>flex-wrap</code>属性控制Flex项目是否换行。默认情况下，Flex容器会在一行内容纳所有的Flex项目，因为<code>flex-wrap</code>属性的默认值是<code>nowrap</code>，也就是不换行。</p><p>具体应用示例如下：<br><img src="http://upload-images.jianshu.io/upload_images/3985563-4b50ce37d7b414fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>其中<code>wrap-reverse</code>表示Flex项目在容器中多行排列，只是方向是反的。</p><h3 id="3-flex-flow"><a href="#3-flex-flow" class="headerlink" title="3. flex-flow"></a>3. flex-flow</h3><p><code>flex-flow</code>是<code>flex-direction</code>和<code>flex-wrap</code>两个属性的速记属性。</p><p>具体不再解释，看下面示例即可：<br><img src="http://upload-images.jianshu.io/upload_images/3985563-61d6759cab65b127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="4-justify-content"><a href="#4-justify-content" class="headerlink" title="4. justify-content"></a>4. justify-content</h3><p><code>justify-content</code>属性，控制Flex项目在整个Main-Axis上的对齐方式。</p><p><code>justify-content</code>的默认属性值是<code>flex-start</code>。</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-5693a49a5527be4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><code>space-between</code>让flex项目两端对齐。</p><p><code>space-around</code>让每个flex项目具有相同的空间</p><h3 id="5-align-items"><a href="#5-align-items" class="headerlink" title="5. align-items"></a>5. align-items</h3><p><code>align-items</code>控制Flex项目在<strong>Cross-Axis</strong>对齐方式。</p><p><code>align-items</code>的默认值是<code>stretch</code>，让所有的Flex项目高度和Flex容器高度一样，铺展开。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-3cd7153bed38c823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>baseline</code>让所有flex项目在Cross-Axis上沿着他们自己的基线对齐。</p><p>其中<code>stretch</code>和<code>baseline</code>在不设置具体高度值，才会如上表现，否则会显示固定的高度。</p><p><code>align-content</code>属性与<code>align-items</code>作用相同，不过该属性只针对多行，对单行无效。</p><h2 id="三、Flex项目"><a href="#三、Flex项目" class="headerlink" title="三、Flex项目"></a>三、Flex项目</h2><p>接下来继续介绍Flex项目的具体属性及使用方法。</p><table><thead><tr><th>属性</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>order</td><td>数值</td><td>根据<code>order</code>值重新排序。从底到高。</td></tr><tr><td>flex-grow</td><td>0  或 positive number</td><td>控制Flex项目在容器有多余的空间如何放大</td></tr><tr><td>flex-shrink</td><td>0   或positive number</td><td>控制Flex项目在容器 没有额外空间又如何缩小</td></tr><tr><td>flex-basis</td><td>auto  或 %  或 em 或  rem 或  px</td><td>指定Flex项目的初始大小</td></tr><tr><td>align-self</td><td>auto  或 flex-start  或 flex-end 或  center  或   baseline 或  stretch</td><td>控制单个Flex项目在<strong>Cross-Axis</strong>对齐方式</td></tr></tbody></table><h3 id="1-order"><a href="#1-order" class="headerlink" title="1. order"></a>1. order</h3><p><code>order</code>允许Flex项目在一个Flex容器中重新排序，属性默认值是0。</p><p>依据<code>order</code>值的大小进行排序，按照值从低到高依次排序。</p><p>默认情况下，排序如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-5e6164ea01ed0e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>当将方块1设置<code>order:1</code>后，排序如下：<br><img src="http://upload-images.jianshu.io/upload_images/3985563-0756d350f4e58789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如果，多个Flex项目具有相同的<code>order</code>值，Flex项目重新排序是基于HTML源文件的位置进行排序。</p><p>如下所示，将方块1和方块2都设置为<code>order:1</code>。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-0596dedef923f8e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2-flex-grow-和-flex-shrink"><a href="#2-flex-grow-和-flex-shrink" class="headerlink" title="2. flex-grow 和 flex-shrink"></a>2. flex-grow 和 flex-shrink</h3><p><code>flex-grow</code>和<code>flex-shrink</code>属性控制Flex项目在容器有多余的空间如何放大（扩展），在没有额外空间又如何缩小。</p><p><code>flex-grow</code>和<code>flex-shrink</code> 的值可以为 0或者大于0的任何正数。</p><p>默认情况下，<code>flex-grow</code>属性值设置为<code>0</code>，表示Flex项目不会增长，填充Flex容器可用空间。</p><p>默认情况下，<code>flex-shrink</code>属性值设置为1，表示Flex项目会缩小，适应屏幕宽度。</p><p>如果把<code>flex-grow</code>的值设置为<code>1</code>，如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/3985563-4aa97f2fce27fb85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>当多个flex项目在一行内，即不换行时，设置不同的<code>flex-grow</code>和<code>flex-shrink</code> 值，对应的空间分配也不同。</p><p><strong><code>flex-grow</code></strong></p><p>将每一个item所设置的 grow 全部加起来，获得可用空间，然后除以总的grow值，得到单位分配空间。</p><p>根据每一个item 设置的 grow 来算，如果一个item 的grow 为 6，那么 这个 item 在主轴上的尺寸就需要延伸 6*单位分配空间的大小。</p><p><strong><code>flex-shrink</code></strong></p><p>先将所有项目 按照 <code>flex-shrink * item-size</code> 的方式加起来 得到一个加权和，然后计算出 每一份 item 的 shrink比例: shrink比例 = flex-shrink <em> item-size / 之前的总和。最后每一个item 减去这个 `shrink比例 </em> 负可用空间`。</p><p>在flex项目有<code>min-width(height)</code>和<code>max-width(height)</code>时，对应的项目要考虑上下限值，把剩余的伸缩值分配给其他项目。</p><h3 id="3-flex-basis"><a href="#3-flex-basis" class="headerlink" title="3. flex-basis"></a>3. flex-basis</h3><p><code>flex-basis</code>指定了 flex 元素在主轴方向上的初始大小，即决定了 flex项目内容的宽或者高（取决于主轴的方向）的尺寸大小。</p><p>默认情况，Flex项目的初始宽度由<code>flex-basis</code>的默认值决定，即：<code>flex-basis: auto</code>。Flex项目宽度的计算是基于内容的多少来自动计算。</p><p><code>flex-basis</code>和<code>width/height</code>有一定的优先级，具体规则如下：</p><ul><li>flex-basis 的优先级比 width/height 非auto高</li><li>width/height auto优先级等于 flex-basis，取两者中的最大值。</li></ul><h3 id="4-align-self"><a href="#4-align-self" class="headerlink" title="4. align-self"></a>4. align-self</h3><p><code>align-self</code> 控制单个项目沿着Cross-Axis的对其方式。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-5ef0d08dd3ce1ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>除了<code>auto</code>之外，上述示例中flex容器设置了<code>align-itmes：center</code>。</p><p><code>auto</code> 是将目标flex项目的值设置为父元素的 <code>align-items</code>值，或者如果该元素没有父元素的话，就设置为 <code>stretch</code>。上述示例中<code>align-items：stretch</code>。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>以上是对flexbox的整体介绍，可以看出其强大与灵活。除此之外，flexbox还有很多其他的特性以及问题，这里就不再介绍，建议看以下两篇文章，写的很好，本文也主要参考了这两篇文章。</p><p><a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">理解Flexbox：你需要知道的一切</a></p><p><a href="https://www.w3cplus.com/css3/flexbox-layout-and-calculation.html" target="_blank" rel="noopener">深入理解 flex 布局以及计算</a></p><p>如果想实践一下对flexbox的掌握，可以试着做百度前端技术学院中的<a href="http://ife.baidu.com/course/detail/id/113" target="_blank" rel="noopener">这个作业</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Flexbox是一个强大而灵活的布局，本篇文章主要对其进行学习了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、Flexbox简介&quot;&gt;&lt;a href=&quot;#一、Flexbox简介&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
      <category term="CSS" scheme="https://lrh1993.github.io/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS float相关详解</title>
    <link href="https://lrh1993.github.io/2017/12/05/CSS-float%E7%9B%B8%E5%85%B3%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lrh1993.github.io/2017/12/05/CSS-float相关详解/</id>
    <published>2017-12-05T03:01:21.000Z</published>
    <updated>2017-12-05T03:11:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>float属性是CSS常用的一个属性，应用场景广泛，同时也是一个难点，涉及到一些相关细节及注意点。因此，就特别整理总结一下。</p></blockquote><h2 id="一、float介绍"><a href="#一、float介绍" class="headerlink" title="一、float介绍"></a>一、float介绍</h2><p>float元素也称为浮动元素，设置了float属性的元素会根据属性值向左或向右浮动。浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对齐进行环绕。简单来说，就是让block元素无视float元素，让inline元素让流水一样围绕着float元素来实现浮动布局。<br>文字环绕图片是float典型的应用场景，如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/3985563-c4411ddb608229cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>html代码<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="built_in">class</span>=<span class="string">"float"</span> src=<span class="string">"image1.jpg"</span>&gt;</span><br><span class="line">&lt;p <span class="built_in">class</span>=<span class="string">"around"</span>&gt;Harry Potter <span class="keyword">is</span> a series <span class="keyword">of</span> fantasy novels written <span class="keyword">by</span> British author J. K. Rowling. The novels chronicle <span class="keyword">the</span> life <span class="keyword">of</span> a young wizard, Harry Potter, <span class="keyword">and</span> his friends Hermione Granger <span class="keyword">and</span> Ron Weasley, all <span class="keyword">of</span> whom are students <span class="keyword">at</span> Hogwarts School <span class="keyword">of</span> Witchcraft <span class="keyword">and</span> Wizardry. &lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>css代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.float</span>&#123;</span><br><span class="line"><span class="attribute">float</span>:left;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.around</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#00ff90</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由上图可以看出，img元素设置了float：left之后会脱离文档流而居于左侧存在。而p元素无视img元素的存在，从窗口的左上角开始流入，但是p元素中的文字意识到img元素的存在而环绕图片流入。并且img元素是漂浮在p元素的上层。</p><h2 id="二、float元素特性"><a href="#二、float元素特性" class="headerlink" title="二、float元素特性"></a>二、float元素特性</h2><h3 id="1-块级框"><a href="#1-块级框" class="headerlink" title="1.块级框"></a>1.块级框</h3><p>不管一个元素是行内元素还是块级元素，如果被设置了浮动，那浮动元素会生成一个块级框，可以设置它的width和height，因此float常常用于制作横向配列的菜单，可以设置大小并且横向排列。</p><p>首先看一个块级元素的例子。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-5bd4efde3c53915f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>html代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"div1"</span>&gt;</span><br><span class="line">&lt;img src=<span class="string">"image1.jpg"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="div2"&gt;</span></span><br><span class="line"><span class="regexp">&lt;img src="image2.jpg"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure></p><p>css代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认情况下，div元素的宽是100%，一旦让该div浮动起来，立刻会像inline元素一样产生包裹性，宽度会跟随内容自适应。</p><p>再来看下行内元素的例子：<br><img src="http://upload-images.jianshu.io/upload_images/3985563-0dad055680d61390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>html代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line">           首页</span><br><span class="line">       <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line">           发现</span><br><span class="line">       <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line">           动态</span><br><span class="line">       <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line">           我的</span><br><span class="line">       <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>css代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123; </span><br><span class="line"><span class="attribute">background</span>: <span class="number">#d32d2d</span>; </span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">400px</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.rule1</span> &#123; </span><br><span class="line"><span class="attribute">float</span>: left; </span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span>; </span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>; </span><br><span class="line"><span class="attribute">background</span>: <span class="number">#eee</span>; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>; </span><br><span class="line"><span class="attribute">text-align</span>: center; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由上图发现，当span设置float属性后，可以指定width，height值。<br>同时可以发现，当多个元素指定为float且同时为left/right时，元素是紧挨着排列，行内宽度不够时再换行排列。</p><h3 id="2-高度崩塌"><a href="#2-高度崩塌" class="headerlink" title="2.高度崩塌"></a>2.高度崩塌</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-daed0cd68fa120d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>html代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"div1"</span>&gt;</span><br><span class="line">&lt;img src=<span class="string">"image1.jpg"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="div2"&gt;</span></span><br><span class="line"><span class="regexp">&lt;img src="image2.jpg"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure></p><p>css代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span> &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将float属性设置给div2内部的img元素，可以看出div2的高度并没有img元素被撑起来，因此又叫高度崩塌。<br>因为将img元素设置为浮动元素，所以脱离文档流。因而div2中认为没有元素，所以产生了高度崩塌。具体怎么解决高度崩塌，后面再介绍。</p><h2 id="三、clear属性"><a href="#三、clear属性" class="headerlink" title="三、clear属性"></a>三、clear属性</h2><p>clear属性的作用是清除浮动。</p><pre><code>clear : none | left | right | both 取值： none  :  默认值。允许两边都可以有浮动对象 left   :  不允许左边有浮动对象 right  :  不允许右边有浮动对象 both  :  不允许有浮动对象</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3985563-80bb7f4fc609fa17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>html代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"div1"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="div2"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure></p><p>css代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid black;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"image1.jpg"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid red;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"image2.jpg"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上图所示，由于div1是浮动元素，所以div2在div1底层铺展。<br>如果想要让div2换行排列，居于div1底端下方，这个时候就要用到clear属性了。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-778c4df1a27bd54c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>css代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid black;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"image1.jpg"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: left;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid red;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"image2.jpg"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要在div2中加入<code>clear: left</code>。</p><p><strong>对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。</strong><br><img src="http://upload-images.jianshu.io/upload_images/3985563-d04d7448a6fdfbbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>以上图为例子说明，div1和div2都设置了<code>float：left</code>。如果在div1的CSS样式中添加clear:right，来迫使div2下移，则没有任何效果。因为这个清除浮动是在div1中调用的，它只能影响div1，不能影响div2。<br>要想让div2下移，就必须在div2的CSS样式中使用浮动。div2的左边有浮动元素div1，因此只要在div2的CSS样式中使用clear:left;来指定div2元素左边不允许出现浮动元素，这样div2就被迫下移一行。</p><h2 id="四、BFC"><a href="#四、BFC" class="headerlink" title="四、BFC"></a>四、BFC</h2><blockquote><p>为什么要介绍BFC，是因为它和float有着密切的关系。</p></blockquote><h3 id="1-BFC的介绍"><a href="#1-BFC的介绍" class="headerlink" title="1.BFC的介绍"></a>1.BFC的介绍</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一些元素，如float元素，如position为absolute,inline-block,table-cell或table-caption的元素，以及overflow属性不为visible的元素，它们将会建立一个新的块级格式化上下文(Block Formatting Context),也就是我们所说的BFC。</p><h4 id="形成"><a href="#形成" class="headerlink" title="形成"></a>形成</h4><p>BFC也是HTML中的一个盒子（看不见而已），只有满足至少下列条件之一才能形成BFC:</p><ul><li>float属性不为none.</li><li>position属性不为static和relative.</li><li>display属性为下列之一:table-cell,table-caption,inline-block, flex,inline-flex.</li><li>overflow属性不为visible.<h4 id="布局规则"><a href="#布局规则" class="headerlink" title="布局规则"></a>布局规则</h4></li><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box<strong>垂直方向</strong>的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ul><p>有些规则可能不太理解，看完下面的内容就会理解。</p><h3 id="2-BFC作用"><a href="#2-BFC作用" class="headerlink" title="2.BFC作用"></a>2.BFC作用</h3><h4 id="消除Margin-Collapse"><a href="#消除Margin-Collapse" class="headerlink" title="消除Margin Collapse"></a>消除Margin Collapse</h4><p>在正常情况下，在一个容器内的所有box将会由上至下依次垂直排列，即我们所说的一个元素占一行，并切垂直相邻的距离(即margin)是由各自的margin决定的，而不是两个margin的叠加。</p><p>让我们看一个例子：</p><p>html代码:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>条目 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>条目 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>条目 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>css代码:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-40256ccab2d7943c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>理想情况下，我们会认为p标签之间的margin应该是它们的和(20px),但实际上却是10px.这其实是collapsing margins(外边距坍塌)。其中flex布局不存在collapsing margins，水平方向上也不存在collapsing margins。</p><p>利用BFC能消除collapsing margins。紧记只有当元素在同一个BFC中时，垂直方向上的margin才会clollpase。如果它们属于不同的BFC，则不会有margin collapse。因此我们可以再建立一个BFC去阻止margin collpase的发生。<br>所以为了让他们的margins变成20，我们只需要用div,建立一个BFC,令p元素处于不同BFC即可。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-fdfa20e0c285b069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>html代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>条目 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>条目 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"newBFC"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>条目 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>css代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.newBFC</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="容纳浮动元素"><a href="#容纳浮动元素" class="headerlink" title="容纳浮动元素"></a>容纳浮动元素</h4><p>就是解决上面遇到的高度崩塌问题。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-75a0e5c8a9fb55dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>只需要将css代码改动一下，增加一个BFC来容纳浮动元素。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span> &#123;</span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，对于解决高度崩塌，还有如下方式：</p><p><strong>增加一个清除浮动的子元素</strong></p><p>html代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"div1"</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"image1.jpg"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="div2"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;img src="image2.jpg"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style="clear: both"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>增加一个div元素，因为是清除元素，会在img元素底部显示，因此会撑起div2高度。</p><h4 id="阻止文本换行"><a href="#阻止文本换行" class="headerlink" title="阻止文本换行"></a>阻止文本换行</h4><p>大多数情况(若没有特殊设置)，如Figure1,文本将会环绕浮动元素,但有时候这并不是我们期望的。我们期待的是Figure2如图:<br><img src="http://upload-images.jianshu.io/upload_images/3985563-e40cb38b4fd36265.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>想要达到图2的效果，只需要将右部的文字区变成一个BFC即可，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-01c0ce789c0ccc3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>以上就是float有关的内容，内容涉及比较多，这也反映出float的重要性，关于float的应用场景非常多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;float属性是CSS常用的一个属性，应用场景广泛，同时也是一个难点，涉及到一些相关细节及注意点。因此，就特别整理总结一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、float介绍&quot;&gt;&lt;a href=&quot;#一、float介绍&quot; cla
      
    
    </summary>
    
      <category term="CSS" scheme="https://lrh1993.github.io/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS定位属性详解</title>
    <link href="https://lrh1993.github.io/2017/11/27/CSS%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lrh1993.github.io/2017/11/27/CSS定位属性详解/</id>
    <published>2017-11-27T07:31:21.000Z</published>
    <updated>2017-11-29T05:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近学习CSS相关知识，定位是其中的一个难点。不了解其中细节，有时候在使用的时候会弄得一团糟。本篇文章整理下关于定位属性的具体理解与应用。</p></blockquote><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-文档流"><a href="#1-文档流" class="headerlink" title="1.文档流"></a>1.文档流</h3><p>在介绍postion之前，有必要先了解下文档流。</p><p>简单说就是元素按照其在 HTML 中的位置顺序决定排布的过程。HTML的布局机制就是用文档流模型的，即块元素（block）独占一行，内联元素（inline），不独占一行。</p><p>一般使用margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“距离”。</p><p>只要不是float和绝对定位方式布局的，都在文档流里面。</p><p>表现如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">   &lt;div <span class="attribute">style</span>=<span class="string">"border:1px solid black"</span>&gt;div1&lt;/div&gt;</span><br><span class="line">&lt;div <span class="attribute">style</span>=<span class="string">"border:1px solid red"</span>&gt;div2&lt;/div&gt;</span><br><span class="line">这是一张图片</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"test.png"</span>&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-e1a00ad378dd24ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2-position属性介绍"><a href="#2-position属性介绍" class="headerlink" title="2.position属性介绍"></a>2.position属性介绍</h3><ul><li>static，默认值。位置设置为static的元素，它始终会处于文档流给予的位置。</li><li>inherit，规定应该从父元素继承 position 属性的值。但是任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。</li><li>fixed，生成绝对定位的元素。默认情况下，可定位于<strong>相对于浏览器窗口</strong>的指定坐标。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。不论窗口滚动与否，元素都会留在那个位置。但当祖先元素具有transform属性且不为none时，就会<strong>相对于祖先元素</strong>指定坐标，而不是浏览器窗口。</li><li>absolute，生成绝对定位的元素，<strong>相对于距该元素最近的已定位的祖先元素</strong>进行定位。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。</li><li>relative，生成相对定位的元素，<strong>相对于该元素在文档中的初始位置进行定位</strong>。通过 “left”、”top”、”right” 以及 “bottom” 属性来设置此元素相对于自身位置的偏移。</li></ul><p><strong>不管是哪种定位，都必须有一个参照物。找对了参照物，就成功了一半。</strong></p><h2 id="二、相对定位"><a href="#二、相对定位" class="headerlink" title="二、相对定位"></a>二、相对定位</h2><p><strong>relative</strong>生成相对定位的元素，相对于其正常位置进行定位。</p><p>相对定位完成的过程如下：</p><ul><li>按默认方式（static）生成一个元素(并且元素像层一样浮动了起来)。</li><li>相对于以前的位置移动，移动的方向和幅度由 left、right、top、bottom 属性确定，偏移前的位置保留不动。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#box1</span> &#123;</span></span><br><span class="line"><span class="undefined">margin: 20px;</span></span><br><span class="line"><span class="undefined">width: 200px;</span></span><br><span class="line"><span class="undefined">height: 200px;</span></span><br><span class="line"><span class="undefined">background-color: yellow;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#box2</span> &#123;</span></span><br><span class="line"><span class="undefined">margin: 20px;</span></span><br><span class="line"><span class="undefined">width: 200px;</span></span><br><span class="line"><span class="undefined">height: 200px;</span></span><br><span class="line"><span class="undefined">background-color: red;</span></span><br><span class="line"><span class="undefined">/*position: relative;</span></span><br><span class="line"><span class="undefined">left: 100px;</span></span><br><span class="line"><span class="undefined">top: 100px;*/</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中box2中的注释代码未生效前，是按照文档流进行排序呈现。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-fedcf2c6d3943c94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>但是，当注释代码取消注释生效后，就会相对文档流中应当呈现的位置进行移动。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-8888ffe8a0bdae65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>所以，相对定位的参照物是它本身。</strong></p><h2 id="三、绝对定位"><a href="#三、绝对定位" class="headerlink" title="三、绝对定位"></a>三、绝对定位</h2><p>绝对定位与相对定位的一大不同之处就是，当我们把一个元素设置成绝对定位，那么<strong>这个元素将会脱离文档流</strong>，其他元素就会认为这个元素不存在于文档流中而填充它原来的位置。绝对定位元素根据它的参照物移动自己的位置，而参照物则需要根据它祖先元素的定位设置来确定。</p><p>所谓根据它祖先元素的定位设置来确定简单理解为：相对于该元素最近的已定位的祖先元素，如果没有一个祖先元素设置定位，那么参照物是body层。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-f1488be6275ed45e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>以上面的图形来展示绝对定位的特性。可以看出最里层是两个盒子，外面嵌套了两层祖先元素。</p><h4 id="1-祖先元素没定位"><a href="#1-祖先元素没定位" class="headerlink" title="1.祖先元素没定位"></a>1.祖先元素没定位</h4><p>在祖先元素没定位的情况下，使用absolute。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box1</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: yellow;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-7fac05338ffbb3a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>在这种情况下，参考物就是body。</strong></p><h4 id="2-祖先元素有定位"><a href="#2-祖先元素有定位" class="headerlink" title="2.祖先元素有定位"></a>2.祖先元素有定位</h4><p>祖先元素只要设置了值不为position:static之外的值，都视为有定位，并且最近的祖先元素会被设置为绝对定位元素的参照物。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#orange</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: orange;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#box1</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: yellow;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">220px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-dfa2ae3eca8ae581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>在这种情况下，参考物就是最近的祖先元素。</strong></p><p>除了上述两种情况外，在用户没给absolute元素设置left/right、top/bottom的情况下，所对应的参考物会有变化。</p><h4 id="3-未设置left-right、top-bottom"><a href="#3-未设置left-right、top-bottom" class="headerlink" title="3.未设置left/right、top/bottom"></a>3.未设置left/right、top/bottom</h4><p>在没设置left/right、top/bottom的情况下，absolute元素的位置就是该元素在文档流里的位置<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box1</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: yellow;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-fb4516d29f27ca8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上图可以看出两个盒子重叠了，这是因为：absolute元素由于没有设置left/right、top/bottom就按照其应该在文档流中出现的位置进行定位，而absolute元素脱离文档流，红色的盒子元素并不知道absolute元素的存在，就继续放置在该位置，并且absolute元素会覆盖正常文档流中的元素。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>主要介绍了相对定位和绝对定位，其他定位方式比较简单，试一试就知道了。另外，相对定位和绝对定位的应用也比较灵活，适用于多种场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近学习CSS相关知识，定位是其中的一个难点。不了解其中细节，有时候在使用的时候会弄得一团糟。本篇文章整理下关于定位属性的具体理解与应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=
      
    
    </summary>
    
      <category term="CSS" scheme="https://lrh1993.github.io/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>React Native初体验</title>
    <link href="https://lrh1993.github.io/2017/10/24/React-Native%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://lrh1993.github.io/2017/10/24/React-Native初体验/</id>
    <published>2017-10-24T12:54:53.000Z</published>
    <updated>2017-10-25T11:50:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>混合开发一直都比较想接触的技术，所以这几天就学习了下React Native的配置及JavaScript的基础，体验一把混合开发的魅力。</p></blockquote><h2 id="一、React-Native介绍"><a href="#一、React-Native介绍" class="headerlink" title="一、React Native介绍"></a>一、React Native介绍</h2><blockquote><p>Learn once，Write anywhere</p></blockquote><p>以下内容来自：<a href="http://www.hangge.com/blog/cache/detail_1458.html" target="_blank" rel="noopener">React Native - 入门介绍（起源、特点、与其它移动技术的比较）</a></p><h3 id="1、起源"><a href="#1、起源" class="headerlink" title="1、起源"></a>1、起源</h3><p>（1）Native App 优点是功能强大、性能优越。但终究是受制于苹果，而且多版本维护十分痛苦。</p><p>（2）为了不受苹果掌控，Facebook 曾花费大量的人力物力进行移动 HTML5 技术研发。虽然有些成果，但始终离 Native App 有差距，而且这个差距可能永远赶不上。</p><p>（3）2012年9月，Facebook 方面承认“Betting on HTML5 was a mistake.”。便放弃移动 HTML5，全力转型 Native App 开发。</p><p>（4）在转型 Native App 开发后，Facebook 内部其实还在研发一种新的移动技术，并开始使用这种技术开发内部 App。这个技术便是 React Native。</p><p>（5）2015年3月，Facebook 正式公开发布 React Native，并将该技术开源。虽然当时开发平台仅支持 Mac OS，部署也仅支持 iOS 平台。</p><p>（6）2015年9月15日，Facebook 发布了 React Native for Android，把 Web 和原生平台的 JavaScript 开发技术扩展到了 Google 的流行移动平台 Android 上。至此，React Native 实现了跨平台的特性。</p><p><a href="http://www.hangge.com/blog/cache/detail_1458.html#" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3985563-4aafa62e95e059a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原文:React Native - 入门介绍（起源、特点、与其它移动技术的比较）"></a></p><h3 id="2、React、React-js、React-Native三者的联系"><a href="#2、React、React-js、React-Native三者的联系" class="headerlink" title="2、React、React.js、React Native三者的联系"></a>2、React、React.js、React Native三者的联系</h3><ul><li>React 是基础框架,提供了一套基础设计实现理念。</li><li>React.js 是在 React 理念的指导下产生的专门用来开发网页的 web 前端框架。与 React 同时出现和发展，React 的相关概念都在 React.js 文档中。</li><li>React Native 是用来开发移动端 app 的。只不过是用了 React.js 那套模式，而底层是对 Native Code 的封装及调用。</li></ul><h3 id="3、React-Native与其它移动技术的比较"><a href="#3、React-Native与其它移动技术的比较" class="headerlink" title="3、React Native与其它移动技术的比较"></a>3、React Native与其它移动技术的比较</h3><p>在 React Native 出现前，我们通常会选择这三种移动技术（Native App、HTML5、Hybrid）之一进行开发。</p><ul><li>Native App：开发原生应用自然性能最好，功能强大。但多平台版本的开发、维护要花费大量的人力物力。</li><li>HTML5：虽然有 Web 的优势，即灵活的布局能力、免发版的敏捷迭代潜力、优秀的跨平台特性。在新闻资讯等一些强排版、弱交互的展示类 App 上大展拳脚。但由于 WebView 在移动设备上的性能制约，始终难成大器，这也是 Facebook 放弃其的原因。</li><li><p>Hybrid：以 Cordova（PhoneGap）为代表的 Hybrid 方式集 Native App 和 Web 优点于一体，使二者相互补短。</p><p>而 React Native 思想与上面三者都不一样。它的底层引擎是 JavaScript Core，但调用的是原生的组件而非 HTML5 组件。这样运行时可以做到与 Navive App 相媲美的性能体验，同时因为 JavaScript 代码可以使用后端强大的 Web 方式管理，既可以做到高效开发，也可以实现快速部署和问题热修复。</p></li></ul><h3 id="4、React-Native的优点"><a href="#4、React-Native的优点" class="headerlink" title="4、React Native的优点"></a>4、React Native的优点</h3><p>（1）性能媲美原生应用</p><p>由于 React Native 提供的组件是对原生 API 的暴露。虽然我们是用 js 写的代码，但实际上调用的是原生 API，原生的 UI 组件。体验上足以媲美原生应用。</p><p>（2）开发效率高</p><p>相比于原生开发，js 学习成本低、语法灵活。允许让 Web 开发者更多地基于现有经验开发 App。</p><p>（3）组件化开发</p><p>React 强调将应用划分成多个互不相关的组件，每个组件作为一个独立的视图。这种类似搭积木的开发方式使得代码结构清晰、通用性高、可移植性高。上一个项目的某些组件，可以很方便地拿来在下一个项目中使用。对于那些优秀的第三方组件，也能很方便地集成到我们项目中来。</p><p>（4）节约开发成本</p><p>百分之90多界面可以通过 React Native 开发，一份代码同时可以适配 Android 和 iOS。并通过一些手段自动匹配不同屏幕大小的手机，再也不需要自己去计算视图的大小和位置。</p><p>（5）实时远程调试</p><p>React Native 的调试比 Cordova 不知道好到哪里去了。开启了实时重载之后，代码一改，app 就自动更新成最新，对于 UI 的搭建简直是省了不少的编译时间。同时可以打开 XCode 实时的看到所有的 log 信息。</p><p>（6）代码热部署</p><p>我们知道 AppStore 审核流程超级久。而由于 React Native 是用的 js 来写的代码，实时编译的过程能让我们实现应用像网页一样做到热更新，随时发布。真正能够做到上架审核一次，永久 0 审核更新。</p><p>（7）有效降低移动应用安装包体积</p><p>对于普通复杂度的移动应用，使用 React Native 实现的安装包会比原生代码实现的安装包大。而当移动应用功能越复杂，React Native 安装包体积相比原生代码安装包就越小。</p><p>比如当原生代码实现的安装包大于 15MB 时，使用 React Native 改写代码后，安装包就小于原生代码实现的安装包。</p><h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><p>基于macOS进行配置。</p><h3 id="1-安装软件"><a href="#1-安装软件" class="headerlink" title="1.安装软件"></a>1.安装软件</h3><p><strong>Homebrew</strong></p><p>Mac系统的包管理器，用于安装NodeJS和一些其他必需的工具软件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/<span class="keyword">install</span>/<span class="keyword">master</span>/<span class="keyword">install</span>)<span class="string">"</span></span><br></pre></td></tr></table></figure><p><strong>Node</strong></p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">brew install <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure><p>安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> config set registry https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org --<span class="built_in">global</span></span><br><span class="line"><span class="built_in">npm</span> config set disturl https:<span class="regexp">//</span><span class="built_in">npm</span>.taobao.org/dist --<span class="built_in">global</span></span><br></pre></td></tr></table></figure><p><strong>React Native命令行工具</strong></p><p>React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g react-<span class="keyword">native</span>-cli</span><br></pre></td></tr></table></figure><p><strong>Watchman</strong></p><p>由Facebook提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>watchman</span><br></pre></td></tr></table></figure><p><strong>Flow</strong></p><p>一个 JavaScript 的静态类型检查器，建议安装它，以方便找出代码中可能存在的类型错误 </p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>flow</span><br></pre></td></tr></table></figure><p><strong>WebStorm</strong><br>一款非常优秀的Web开发工具，同样支持React Native开发。<br>下载地址：<a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">https://www.jetbrains.com/webstorm/</a>  </p><p><strong>Android及iOS开发必备</strong></p><ul><li>Android Studio</li><li>Genymotion</li><li>Xcode</li></ul><h3 id="2-测试安装"><a href="#2-测试安装" class="headerlink" title="2.测试安装"></a>2.测试安装</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">react-native init FirstApp</span><br><span class="line">cd FirstApp</span><br><span class="line">react-native <span class="keyword">run</span><span class="bash">-android</span></span><br><span class="line"><span class="bash">react-native run-ios</span></span><br></pre></td></tr></table></figure><p>到此，就可以分别在Android和iOS平台上运行项目。自己在配置过程中，也出现了一些坑。如果配置过程中出现问题，建议google查一下相关解决方案。</p><h2 id="三、预备知识"><a href="#三、预备知识" class="headerlink" title="三、预备知识"></a>三、预备知识</h2><ul><li>JavaScript：<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">JavaScript教程</a></li><li>ES6：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></li></ul><p>准备好这些，终于可以开始学习React Native。目前看React Native还很神秘，接下来继续努力，揭开它神秘的面纱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;混合开发一直都比较想接触的技术，所以这几天就学习了下React Native的配置及JavaScript的基础，体验一把混合开发的魅力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、React-Native介绍&quot;&gt;&lt;a href=&quot;#一
      
    
    </summary>
    
      <category term="React Native" scheme="https://lrh1993.github.io/categories/React-Native/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文章，全面总结Android面试知识点</title>
    <link href="https://lrh1993.github.io/2017/10/17/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93Android%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://lrh1993.github.io/2017/10/17/一篇文章，全面总结Android面试知识点/</id>
    <published>2017-10-16T23:22:21.000Z</published>
    <updated>2017-10-17T01:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章的所有知识点是亲身经历十余家一二线互联网企业面试后总结产出，包含应聘Android开发岗位的各个方面的高频知识点，主要针对但不局限于Android应届面试。以下所有知识点都整理发布在Github/Gitbook，方便大家整理学习，文末附有链接。</p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul><li><p>Java基础</p><ul><li>Java集合框架</li><li>Java集合——ArrayList</li><li>Java集合——LinkedList</li><li>Java集合——HashMap</li><li>Java集合——TreeMap</li><li>Java集合——LinkedHashMap</li><li>Java泛型</li><li>Java反射(一)</li><li>Java反射(二)</li><li>Java反射(三)</li><li>Java注解</li><li>Java IO(一)</li><li>Java IO(二)</li><li>RandomAccessFile</li><li>Java NIO</li><li>Java异常详解</li><li>Java抽象类和接口的区别</li><li>Java深拷贝和浅拷贝</li><li>Java transient关键字</li><li>Java finally与return执行顺序</li><li>Java 8 新特性</li></ul></li><li><p>Java并发</p><ul><li>Java创建线程的三种方式</li><li>Java线程池</li><li>死锁</li><li>Synchronized/ReentrantLock</li><li>生产者/消费者模式</li><li>volatile关键字</li><li>CAS原子操作</li><li>AbstractQueuedSynchronizer详解</li><li>深入理解ReentrantLock</li><li>Java并发集合——ArrayBlockingQueue</li><li>Java并发集合——LinkedBlockingQueue</li><li>Java并发集合——ConcurrentHashMap</li></ul></li><li><p>Java虚拟机</p><ul><li>对象的创建、内存布局和访问定位</li><li>Java内存区域与内存模型</li><li>Java类加载机制及类加载器详解</li><li>JVM中垃圾收集算法及垃圾收集器详解</li><li>JVM怎么判断对象是否已死？</li></ul></li></ul><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul><li><p>Android基础</p><ul><li>Activity全方位解析</li><li>Service全方位解析</li><li>BroadcastReceiver全方位解析</li><li>ContentProvider全方位解析</li><li>Fragment详解</li><li>Android消息机制</li><li>Android事件分发机制</li><li>AsyncTask详解</li><li>HandlerThread详解</li><li>IntentService详解</li><li>LruCache原理解析</li><li>Window、Activity、DecorView以及ViewRoot之间的关系</li><li>View测量、布局及绘制原理</li><li>Android虚拟机及编译过程</li><li>Android进程间通信方式</li><li>Android Bitmap压缩策略</li><li>Android动画总结</li><li>Android进程优先级</li><li>Android Context详解</li></ul></li><li><p>Android进阶</p><ul><li>Android多线程断点续传</li><li>Android全局异常处理</li><li>Android MVP模式详解</li><li>Android Binder机制及AIDL使用</li><li>Android Parcelable和Serializable的区别</li><li>一个APP从启动到主页面显示经历了哪些过程？</li><li>Android性能优化总结</li><li>Android 内存泄漏总结</li><li>Android布局优化之include、merge、ViewStub的使用</li><li>Android权限处理</li><li>Android热修复原理</li><li>Android插件化入门指南</li><li>VirtualApk解析</li><li>Android推送技术解析</li><li>Android Apk安装过程</li><li>PopupWindow和Dialog区别</li></ul></li><li><p>开源框架</p><ul><li>OkHttp解析</li><li>Retrofit解析</li><li>EventBus解析</li></ul></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>线性表</li><li>栈和队</li><li>树<ul><li>树的基础</li><li>其他常见的树</li><li>并查集</li><li>B-树，B+树，B*树</li></ul></li><li>图<ul><li>图的基础</li><li>拓扑排序</li><li>Kruskal算法</li><li>Prim算法</li><li>Dijkstra算法</li><li>Floyd算法</li></ul></li><li>散列查找</li><li>排序</li><li>海量数据处理</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>剑指offer</li><li>LeetCode</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>创建型模式<ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>单例模式</li><li>建造者模式</li></ul></li></ul><ul><li>结构型模式<ul><li>适配器模式外观模式</li><li>装饰者模式</li><li>代理模式</li></ul></li></ul><ul><li>行为型模式<ul><li>命令模式</li><li>迭代器模式</li><li>观察者模式</li><li>策略模式</li><li>模板方法模式</li></ul></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>TCP/IP</li><li>HTTP</li><li>HTTPS</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>概述</li><li>进程与线程</li><li>内存管理</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>SQL语句</li></ul><p><strong>Github地址：</strong><a href="https://github.com/LRH1993/android_interview" target="_blank" rel="noopener">https://github.com/LRH1993/android_interview</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇文章的所有知识点是亲身经历十余家一二线互联网企业面试后总结产出，包含应聘Android开发岗位的各个方面的高频知识点，主要针对但不局限于Android应届面试。以下所有知识点都整理发布在Github/Gitbook，方便大家整理学习，文末附有链
      
    
    </summary>
    
      <category term="面试" scheme="https://lrh1993.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>2017 Android秋招面试总结</title>
    <link href="https://lrh1993.github.io/2017/10/11/2017-Android%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://lrh1993.github.io/2017/10/11/2017-Android秋招面试总结/</id>
    <published>2017-10-11T09:44:53.000Z</published>
    <updated>2017-10-25T11:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个多月没有更新博客了，一直在忙着找工作。现在已经尘埃落定，最终选择了网易。 这篇文章主要总结一下自己秋招的经历与准备。</p></blockquote><h3 id="一、经历"><a href="#一、经历" class="headerlink" title="一、经历"></a>一、经历</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-8e7bd957dec4efb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="1-学习经历"><a href="#1-学习经历" class="headerlink" title="1.学习经历"></a>1.学习经历</h4><p>作为一个双非渣硕非CS专业的应届生，接触并学习Android开发也就是最近一年多的时间，不过好在没走太多的弯路。</p><p>从去年暑假开始看视频学习Android，刚开始感觉自己很笨，出个小问题就懵逼了，往往鼓捣一天都毫无头绪，不过后来随着对理论的学习就变得好很多了。到16年11月份，开始看一些Java和Android方面的书籍，如《深入理解Java虚拟机》、《Android开发艺术探索》等。看了几本书后，感觉基础掌握的并不牢靠，实践能力薄弱，所以到了17年1月份后开始写技术博客和做练手项目。不得不说写作技术博客对技术的提升很快，其中的益处切身体会更能理解。而自己做一些练手项目，既增强自己的实践能力，同时提高了自身的竞争力。因为并不是科班出身，所以实践的机会很少。自己做的一些项目，虽然low一些，不过挖掘几个技术点，同时加入点项目趣味性，还是可以在面试中帮你增色不少。</p><p>以上大概就是自己从接触Android以来的学习过程，可能和多数人的历程一致，不过一步一个脚印，踏踏实实低走下来还是很有收获的。</p><h4 id="2-实习经历"><a href="#2-实习经历" class="headerlink" title="2.实习经历"></a>2.实习经历</h4><p>今年3月份开始找暑期实习，历经两个月的时间，最终去今日头条实习。</p><p>关于暑期实习面试的经验，可以看这篇文章：<a href="http://lruheng.com/2017/05/09/2017-Android%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E8%B0%88/" target="_blank" rel="noopener">2017 Android暑期实习生面试经验谈</a></p><p>在头条实习的这段时间，进步很大，了解到了很多东西。从产品的开发流程，到android的各个技术方面。了解了一款商业级产品开发的方方面面，这是自己平时做项目永远也无法接触到的，也是平台所带给的优势。不得不说，头条的技术氛围很不错。</p><p>由于各方面原因，更倾向于到杭州生活，所以在8月中下旬不得不离开了头条，开启了秋招之路。另外多说几句，现在一些一二线大厂越来越注重暑期实习生的招聘，转正留用的概率也很大。同时暑期实习招聘相对于秋招来说，难度与竞争也要小很多，所以学弟学妹们还是尽量早作准备，争取在暑期实习招聘就能拿到意向公司的offer。即便没有拿到意向offer，也要多去尝试，刷点面试经验，同时一份不错的实习经历也为你的秋招增加更多的筹码。</p><h4 id="3-秋招经历"><a href="#3-秋招经历" class="headerlink" title="3.秋招经历"></a>3.秋招经历</h4><p>8月底开始海投简历，到这个时候才知道秋招的残酷。BAT从七月就开始内推，8月底内推都结束了…… 海投简历，狂做笔试，奔波面试，基本整个九月就是这样过来的。粗略估计应该投了三四十家公司，9月15号之前基本一天两场甚至三场笔试。20-30号之间就开始了疯狂面试，一天一场或两场。有时候一天两场现场面试，打时间差各种奔波，身体和精神都很疲惫。</p><p>幸好结果还不错，在十一之前结束了秋招。整个秋招的面试经历大致如下：</p><ul><li>滴滴、腾讯 笔试挂</li><li>金山云   工作地点原因没参加二面</li><li>京东、趋势科技     二面挂</li><li>大疆、b站 要求上海现场面，没去参加终面   </li><li>网易、美团、360、CVTE、中兴、苏宁、有赞、51信用卡、贝贝、东方财富 offer</li></ul><p>还有一些没去面试或者没做笔试。其中，阿里内推截止前投了一下，还投错部门了，草草地面了十几分钟就给回绝了，校招笔试也没过，很遗憾。由于想去杭州，所以基本杭州的一些大小公司都面了个遍…….</p><h3 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-9a7b2edbadac9041.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>关于面经，网上有很多，也都大同小异，核心知识点都差不多。自己在秋招的过程中也总结了一下，暂时还没完成，不过也快了，接下来几天会系统整理下。正在找工作的小伙伴可以参考一下，下面附上地址：</p><p>GIthub地址:<a href="https://github.com/LRH1993/android_interview" target="_blank" rel="noopener">https://github.com/LRH1993/android_interview</a></p><p>Gitbook地址:<a href="https://www.gitbook.com/book/lrh1993/android_interview_guide/details" target="_blank" rel="noopener">https://www.gitbook.com/book/lrh1993/android_interview_guide/details</a></p><p>下面主要介绍下，针对秋招，自己所做的准备。主要涉及以下方面:</p><p><strong>Java</strong></p><ul><li>Java基础</li><li>Java并发</li><li>Java虚拟机</li></ul><p><strong>Android</strong></p><ul><li>Android基础</li><li>Android进阶</li><li>开源框架</li></ul><p><strong>数据结构</strong></p><ul><li>线性表</li><li>栈和队</li><li>树</li><li>图</li><li>散列查找</li><li>排序</li><li>海量数据处理</li></ul><p><strong>算法</strong></p><ul><li>剑指offer</li><li>LeetCode</li></ul><p><strong>设计模式</strong></p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><p><strong>计算机网络</strong></p><ul><li>TCP/IP</li><li>HTTP</li><li>HTTPS</li></ul><p><strong>操作系统</strong></p><ul><li>概述</li><li>进程与线程</li><li>内存管理</li></ul><p><strong>数据库</strong></p><ul><li>SQL语句</li></ul><p>关于以上内容，上面给出的两个链接中都有整理。不过也不要盲目为面试做准备，要想要打好基础，还是要多看看相关的书籍和博客。</p><p>关于书籍，在学习的过程中，主要看了这么几本：《疯狂Java讲义》、《深入理解Java虚拟机》、《Head First 设计模式》、《Android群英传》、《Android开发艺术探索》、《大话数据结构》等。</p><p>关于博客，在学习的过程中，主要关注了几位大佬：<a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="noopener">Hongyang</a>、<a href="http://gityuan.com/" target="_blank" rel="noopener">Gityuan</a>、<a href="https://blog.piasy.com/" target="_blank" rel="noopener">Piasy</a>、<a href="http://www.jianshu.com/u/90ab66c248e6" target="_blank" rel="noopener">占小狼</a>等。</p><p>除此之外，还有一项重要内容，就是准备相关项目。对于项目的准备，还需要自行包装，突出亮点。对于新手而言，可参考这篇文章：<a href="http://www.jianshu.com/p/052d69d72c96" target="_blank" rel="noopener">Android新手如何学习开发一款app?</a></p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-a0c2013e4131bcea.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>2017年大约半年的时间都在准备找工作与找工作的过程中，很特别的一段历程。</p><p>以过来人的身份提个建议：早作准备，锁定暑期实习，尽量避免秋招，说多了都是泪……</p><p>学习技术的脚步不能停，接下来把面试的相关东西整理一下，继续储备知识为工作而准备！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一个多月没有更新博客了，一直在忙着找工作。现在已经尘埃落定，最终选择了网易。 这篇文章主要总结一下自己秋招的经历与准备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、经历&quot;&gt;&lt;a href=&quot;#一、经历&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="面试" scheme="https://lrh1993.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Android图文混排实现方式详解</title>
    <link href="https://lrh1993.github.io/2017/08/30/Android%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://lrh1993.github.io/2017/08/30/Android图文混排实现方式详解/</id>
    <published>2017-08-30T12:37:57.000Z</published>
    <updated>2017-09-01T00:20:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在使用TextView的时候，我们经常需要在TextView中进行图文混排，比如在QQ中聊天的消息中的表情，底部tab图标等。</p></blockquote><h2 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h2><p><img src="http://upload-images.jianshu.io/upload_images/3985563-e65670dd936959ec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><p>Android官方对TextView的图文混排提供了支持，我们可以从以下三种方式实现TextView的图文混排：</p><p>1.在TextView中使用Compound Drawable属性；<br>2.在TextView中使用Spannable多样式显示；<br>3.在TextView中显示HTML文本。</p><h2 id="三、drawable属性"><a href="#三、drawable属性" class="headerlink" title="三、drawable属性"></a>三、drawable属性</h2><p>在TextView中使用Compound Drawable属性可以在文字的上下左右放置drawable，效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/3985563-cab6ba24c22fc8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>一共有两种方式可以实现：XML布局设置和Java代码设置。</p><h3 id="1-xml布局"><a href="#1-xml布局" class="headerlink" title="1. xml布局"></a>1. xml布局</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">       android:<span class="attribute">gravity</span>=<span class="string">"center"</span></span><br><span class="line">       android:<span class="attribute">layout_width</span>=<span class="string">"wrap_content"</span></span><br><span class="line">       android:<span class="attribute">layout_height</span>=<span class="string">"wrap_content"</span></span><br><span class="line">       android:<span class="attribute">text</span>=<span class="string">"查看新的内容"</span></span><br><span class="line">       android:<span class="attribute">textSize</span>=<span class="string">"18sp"</span></span><br><span class="line">       android:<span class="attribute">drawablePadding</span>=<span class="string">"10dp"</span></span><br><span class="line">       android:<span class="attribute">drawableLeft</span>=<span class="string">"@drawable/arrow"</span>/&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>android:drawableLeft</th><th>在文字左边设置图片</th></tr></thead><tbody><tr><td>android:drawableTop</td><td>在文字上边设置图片</td></tr><tr><td>android:drawableRight</td><td>在文字右边设置图片</td></tr><tr><td>android:drawableBottom</td><td>在文字下边设置图片</td></tr><tr><td>android:drawableStart</td><td>API 17后生效，LTR时在左边，RTL时在右边</td></tr><tr><td>android:drawableEnd</td><td>API 17后生效，LTR时在右边，RTL时在左边</td></tr><tr><td>android:drawablePadding</td><td>图片和文字的间距</td></tr></tbody></table><h3 id="2-java代码"><a href="#2-java代码" class="headerlink" title="2. java代码"></a>2. java代码</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">textView = (TextView) findViewById(R.id.textView)<span class="comment">;</span></span><br><span class="line">Drawable drawable = getResources().getDrawable(R.drawable.see)<span class="comment">;</span></span><br><span class="line">drawable.setBounds(<span class="number">0</span>,<span class="number">0</span>,drawable.getIntrinsicWidth(),drawable.getIntrinsicHeight())<span class="comment">;</span></span><br><span class="line">textView.setCompoundDrawables(null,null,null,drawable)<span class="comment">;</span></span><br><span class="line">textView.setCompoundDrawablePadding(<span class="number">10</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>注意：必须setBounds()测量图片边界，否则不显示。</p><table><thead><tr><th>setCompoundDrawables</th><th>设置上下左右位置的图片</th></tr></thead><tbody><tr><td>setCompoundDrawablesRelative</td><td>设置四周的图片，其中两边对应xml中的start,end</td></tr><tr><td>setCompoundDrawablesWithIntrinsicBounds</td><td>设置上下左右位置的图片，图片有默认的边界</td></tr><tr><td>setCompoundDrawablesRelativeWithIntrinsicBounds</td><td>设置四周的图片，图片有默认的边界</td></tr><tr><td>setCompoundDrawablePadding</td><td>设置图片与文字之间的间距</td></tr></tbody></table><h3 id="3-缺陷"><a href="#3-缺陷" class="headerlink" title="3.缺陷"></a>3.缺陷</h3><p>当TextView设置成固定大小时，由于文字距离边界的距离过大，会导致文字与图片之间设置的间距无效，如下图。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-1730c069151644b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>①设置TextView的内填充</p><p>通过设置paddingLeft、paddingRight、paddingTop、paddingBottom来缩写这个间距</p><p>②自定义TextView重新布局</p><p>a.先自定义属性iconPadding来设置间距，并提供方法给外部调用。</p><p>b.重写setCompoundDrawablesWithIntrinsicBounds()方法来获取我们设置的drawable宽高。</p><p>c.最后重写onLayout方法。</p><p>可以先参考：<a href="https://yuxingxin.com/2015/11/05/DrawablePadding/" target="_blank" rel="noopener">Android技巧之drawablePadding的那些事</a>,该篇文章只解决了左右失效的问题。后期会整理个解决图文混排的工具库，里面会有具体方案。</p><h2 id="四、Spannable使用"><a href="#四、Spannable使用" class="headerlink" title="四、Spannable使用"></a>四、Spannable使用</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>setText(CharSequence text)中接收的是CharSequence。而SpannableString和SpannableStringBuilder是其实现类，是可以直接赋值的。并且两者的setSpan()方法可以设置一些格式对象（例如字体大小、下划线、替换为图片等），这就可以实现富文本了。</p><p>Spannable实现子类：SpannableString，SpannableStringBuilder（可变，类似于StringBuilder）。</p><p>Spannable中定义了抽象方法：setSpan(Object what, int start, int end, int flags)和removeSpan(Object what)。这两个方法实现了对字符串的灵活编辑。</p><p>其中setSpan()方法包含如下参数：</p><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>what</td><td>span样式</td></tr><tr><td>start</td><td>样式开始的索引</td></tr><tr><td>end</td><td>样式结束的索引</td></tr><tr><td>flags</td><td>样式作用的范围</td></tr></tbody></table><p>flags常用的有四种</p><table><thead><tr><th>SPAN_INCLUSIVE_INCLUSIVE</th><th>前后都包括，在指定范围前后插入新字符，都会应用新样式</th></tr></thead><tbody><tr><td>SPAN_EXCLUSIVE_EXCLUSIVE</td><td>前后都不包括，在指定范围前后插入新字符，两端样式无变化</td></tr><tr><td>SPAN_INCLUSIVE_EXCLUSIVE</td><td>前面包括，后面不包括</td></tr><tr><td>SPAN_EXCLUSIVE_INCLUSIVE</td><td>后面包括，前面不包括</td></tr></tbody></table><p>通常在insert方式才生效，平时不生效，具体看：<a href="https://stackoverflow.com/questions/9879233/explain-the-meaning-of-span-flags-like-span-exclusive-exclusive" target="_blank" rel="noopener"><a href="https://stackoverflow.com/questions/9879233/explain-the-meaning-of-span-flags-like-span-exclusive-exclusive" target="_blank" rel="noopener">Explain the meaning of Span flags like SPAN_EXCLUSIVE_EXCLUSIVE</a></a>。</p><h3 id="2-常用span类"><a href="#2-常用span类" class="headerlink" title="2.常用span类"></a>2.常用span类</h3><table><thead><tr><th style="text-align:left">常用类</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">BackgroundColorSpan</td><td>背景色样式，显然可以用来设定文本的背景色</td></tr><tr><td style="text-align:left">ForegroundColorSpan</td><td>字体颜色样式，用于改变字体颜色</td></tr><tr><td style="text-align:left">StyleSpan</td><td>主要由正常、粗体、斜体和同时加粗倾斜四种样式</td></tr><tr><td style="text-align:left">TypefaceSpan</td><td>设置不同的字体</td></tr><tr><td style="text-align:left">ImageSpan</td><td>图片样式，主要用于在文本中插入图片</td></tr><tr><td style="text-align:left">URLSpan</td><td>可以打开一个链接</td></tr><tr><td style="text-align:left">UnderlineSpan</td><td>下划线样式</td></tr><tr><td style="text-align:left">StrikethroughSpan</td><td>删除线样式</td></tr></tbody></table><h3 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3.使用方式"></a>3.使用方式</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">SpannableString span3 = <span class="keyword">new</span> SpannableString(<span class="string">"我如果爱你"</span>);</span><br><span class="line">ImageSpan <span class="built_in">image</span> = <span class="keyword">new</span> ImageSpan(<span class="keyword">this</span>,R.drawable.collect, DynamicDrawableSpan.ALIGN_BOTTOM);</span><br><span class="line">span3.setSpan(<span class="built_in">image</span>,<span class="number">3</span>,<span class="number">4</span>, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">tv3.setText(span3);</span><br></pre></td></tr></table></figure><p>其中ImageSpan默认对其方式有两种：ALIGN_BOTTOM及ALIGN_BASELINE。很可惜我们平常用的居中对其的方式没有，不过可以通过自定义实现，后续会在开源出来。</p><h3 id="4-效果"><a href="#4-效果" class="headerlink" title="4.效果"></a>4.效果</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-0f942b4c39b84fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="五、HTML显示"><a href="#五、HTML显示" class="headerlink" title="五、HTML显示"></a>五、HTML显示</h2><p>一般显示HTML内容有两种方式：</p><ul><li>使用 Android 提供的 WebView 控件。</li><li>通过将 HTML 内容转化为 Spanned 格式在 TextView 中进行显示。</li></ul><p>现在大多数都用WebView的方式。但是并不是所有的场景下都适合使用 WebView 来显示 HTML 内容，例如，如果应用要显示的内容只是一部分 HTML 片段，就可以利用 TextView 来进行显示，并且效率较高。</p><p>由于这种方式不太常用，就不深入介绍，里面可以实现的效果还是很好的。</p><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h3><p>Android 中的 TextView 组件常用于显示文本内容，其实它也可以显示 HTML 的内容。</p><p>简单来讲，这就需要先把 HTML 的内容以字符串的形式获取后，经过 android.text.Html.fromHtml()转化成 Spanned 的格式，然后将其传递到 TextView 的 setText()方法中，这样就可以在 TextView 中显示 HTML 页面的内容了。</p><p>需要注意的是，并不是所有的 HTML 标签在 TextView 中都是支持的，且官方文档并没有明确的说明支持 HTML 标签列表，通过查看 Android 源代码，可以得到简单的支持列表。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>,<span class="tag">&lt; <span class="attr">p</span>&gt;</span>,<span class="tag">&lt; <span class="attr">div</span> <span class="attr">align</span>=&gt;</span>,<span class="tag">&lt; <span class="attr">strong</span>&gt;</span>, <span class="tag">&lt;<span class="name">b</span>&gt;</span>, <span class="tag">&lt;<span class="name">em</span>&gt;</span>, <span class="tag">&lt;<span class="name">cite</span>&gt;</span>, <span class="tag">&lt;<span class="name">dfn</span>&gt;</span>, <span class="tag">&lt;<span class="name">i</span>&gt;</span>, <span class="tag">&lt;<span class="name">big</span>&gt;</span>, <span class="tag">&lt;<span class="name">small</span>&gt;</span>, <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=&gt;</span>,  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=&gt;</span>, <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>, <span class="tag">&lt;<span class="name">tt</span>&gt;</span>, <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=&gt;</span>,</span><br><span class="line"> <span class="tag">&lt;<span class="name">u</span>&gt;</span>,  <span class="tag">&lt;<span class="name">sup</span>&gt;</span>,  <span class="tag">&lt;<span class="name">sub</span>&gt;</span>, <span class="tag">&lt;<span class="name">h1</span>&gt;</span>,<span class="tag">&lt;<span class="name">h2</span>&gt;</span>,<span class="tag">&lt;<span class="name">h3</span>&gt;</span>,<span class="tag">&lt;<span class="name">h4</span>&gt;</span>,<span class="tag">&lt;<span class="name">h5</span>&gt;</span>,<span class="tag">&lt;<span class="name">h6</span>&gt;</span>,  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=&gt;</span>, <span class="tag">&lt;<span class="name">strike</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面的示例来介绍如何在 TextView 中显示一段 HTML 内容，要显示的这段 HTML 内容即包含超链接内容，也包含有图片。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p><strong>fromHtml方法</strong><br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">fromHtml</span><span class="params">(String source, ImageGetter imageGetter,TagHandler tagHandler)</span></span></span><br></pre></td></tr></table></figure></p><ul><li>source，就是包含 HTML 内容的字符串。Html.ImageGetter 和 Html.TagHandler 是两个接口，提供给开发者继承使用。</li><li>imageGetter， 如果要显示图片是需要被继承的，重写 getDrawable(String source)方法，用于获取 HTML 里面的图片来显示在 TextView 中。</li><li>tagHandler，其作用是把 HTML 带标记的文本内容字符串转化成可以显示效果的的 Spanned 字符串 。由于并非所有的 HTML 标签都可以转化，所以在使用时，用户需要自己添加一些必要的标签和处理方法时才会继承使用的。</li></ul><p><strong>继承ImageGetter</strong></p><p>继承于 ImageGetter，重写 getDrawable (String source) 方法。通过异步操作，读取本地/网络资源，获得drawable对象。</p><p><strong>继承TagHandler</strong></p><p>继承于 TagHandler，重写了 handleTag()方法。为了支持更多的标签，例如为了支持<code>&lt;ul&gt;&lt;ol&gt;&lt;dd&gt;</code>和<code>&lt;li&gt;</code>标签，这四个标签是在 formHtml()方法中本身是不支持。</p><p>如果开发者认为安卓 TagHandler 提供的默认标签解析已经够用，直接在 fromHtml()方法中第三个参数的地方填写 null 既可。</p><p>最后，通过 formHtml()方法将 HTML 内容转化为可供显示的 SpannableString，将 SpannableString 通过 setText 方法放入 TextView 中，就可以显示图文并茂的内容了。</p><p><strong>用户交互</strong></p><p>formHtml()方法已经将 HTML 内容中的超链接和图片转义成为 UrlSpan 和 ImageSpan，进而在 TextView 中完成显示。但是此时是没有任何用户交互的，用户只能看到 HTML 的内容，下面介绍如何添加用户交互功能。</p><p>要完成用户交互，这里我们需要在 TextView 中还需要调用textView.setMovementMethod()方法。</p><p>Android 提供了 LinkMovementMethod 类以实现了对于文本内容中超链接的遍历，并且支持对于超链接的点击事件。</p><p>所以只要在添加下面一行代码，就可以使点击 UrlSpan 能够触发打开链接的功能。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">textView</span><span class="selector-class">.setMovementMethod</span>(<span class="selector-tag">LinkMovementMethod</span><span class="selector-class">.getInstance</span>())</span><br></pre></td></tr></table></figure></p><p>如果想要更多的用户交互效果，可以自定义LinkMovementMethod 类，重写onTouchEvent方法来实现。</p><h3 id="3-效果"><a href="#3-效果" class="headerlink" title="3.效果"></a>3.效果</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-f3a5bd6b3e539d70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>点击图片，跳转到图片详情页。</p><p>关于HTML显示这部分，没做具体实现。具体可以看：<a href="https://www.ibm.com/developerworks/cn/web/1407_zhangqian_androidhtml/index.html" target="_blank" rel="noopener">灵活高效的在 Android Native App 开发中显示 HTML 内容</a>,里面有具体源码可以下载，HTML部分内容也是参考该篇文章完成的。<br>开源库：<a href="https://github.com/PrivacyApps/html-textview" target="_blank" rel="noopener">html-textview</a></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>以上就是关于图文混排的一些解决方案，相信通过这些了解，对于工作中的实际场景的使用大家会有适当的解决方案。由于实际应用较少，所以认识较为浅显，可能有些地方描述不当，后期会考虑封装个解决图文混排的工具类，加深下理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在使用TextView的时候，我们经常需要在TextView中进行图文混排，比如在QQ中聊天的消息中的表情，底部tab图标等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、场景&quot;&gt;&lt;a href=&quot;#一、场景&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="Android基础" scheme="https://lrh1993.github.io/categories/Android%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇文章，教你学会Git</title>
    <link href="https://lrh1993.github.io/2017/08/23/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E6%95%99%E4%BD%A0%E5%AD%A6%E4%BC%9AGit/"/>
    <id>https://lrh1993.github.io/2017/08/23/一篇文章，教你学会Git/</id>
    <published>2017-08-23T07:41:21.000Z</published>
    <updated>2017-08-26T12:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在日常工作中，经常会用到Git操作。但是对于新人来讲，刚上来对Git很陌生，操作起来也很懵逼。本篇文章主要针对刚开始接触Git的新人，理解Git的基本原理，掌握常用的一些命令。</p></blockquote><h2 id="一、Git工作流程"><a href="#一、Git工作流程" class="headerlink" title="一、Git工作流程"></a>一、Git工作流程</h2><p><img src="http://upload-images.jianshu.io/upload_images/3985563-ade5b67f52f8675c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>以上包括一些简单而常用的命令，但是先不关心这些，先来了解下面这4个专有名词。</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><p><strong>工作区</strong> </p><p>程序员进行开发改动的地方，是你当前看到的，也是最新的。</p><p>平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。</p><p><strong>暂存区</strong> </p><p>.git目录下的index文件, 暂存区会记录<code>git add</code>添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用<code>git status</code>查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。</p><p>当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过<code>git add</code>先提交到暂存区，被git管理。</p><p><strong>本地仓库</strong></p><p>保存了对象被提交 过的各个版本，比起工作区和暂存区的内容，它要更旧一些。</p><p><code>git commit</code>后同步index的目录树到本地仓库，方便从下一步通过<code>git push</code>同步本地仓库与远程仓库的同步。</p><p><strong>远程仓库</strong></p><p>远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>任何对象都是在工作区中诞生和被修改；</li><li>任何修改都是从进入index区才开始被版本控制；</li><li>只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；</li><li>与协作者分享本地的修改，可以把它们push到远程仓库来共享。</li></ol><p>下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-6b745d5fac15906c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="二、常用Git命令"><a href="#二、常用Git命令" class="headerlink" title="二、常用Git命令"></a>二、常用Git命令</h2><p><img src="http://upload-images.jianshu.io/upload_images/3985563-c7f05348b711ebbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>网上找了个图，别人整理的一张图，很全很好，借来用下。下面详细解释一些常用命令。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-623d3cefdcb95045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在掌握具体命令前，先理解下HEAD。</p><p>HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-a5f92bd6f800959f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>add相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。</p><table><thead><tr><th style="text-align:left"><strong>git add .</strong></th><th><strong>添加当前目录的所有文件到暂存区</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>git add <dir></dir></strong></td><td><strong>添加指定目录到暂存区，包括子目录</strong></td></tr><tr><td style="text-align:left"><strong>git add <file1></file1></strong></td><td><strong>添加指定文件到暂存区</strong></td></tr></tbody></table><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-a5f92bd6f800959f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>commit相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的HEAD向后移动一个提交点。</p><table><thead><tr><th><strong>git commit -m <message></message></strong></th><th><strong>提交暂存区到本地仓库,message代表说明信息</strong></th></tr></thead><tbody><tr><td><strong>git commit <file1> -m <message></message></file1></strong></td><td><strong>提交暂存区的指定文件到本地仓库</strong></td></tr><tr><td><strong>git commit –amend -m <message></message></strong></td><td><strong>使用一次新的commit，替代上一次提交</strong></td></tr></tbody></table><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-04bac8d079111a9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。</p><table><thead><tr><th><strong>git branch</strong></th><th><strong>列出所有本地分支</strong></th></tr></thead><tbody><tr><td><strong>git branch -r</strong></td><td><strong>列出所有远程分支</strong></td></tr><tr><td><strong>git branch -a</strong></td><td><strong>列出所有本地分支和远程分支</strong></td></tr><tr><td><strong>git branch <branch-name></branch-name></strong></td><td><strong>新建一个分支，但依然停留在当前分支</strong></td></tr><tr><td><strong>git checkout -b <branch-name></branch-name></strong></td><td><strong>新建一个分支，并切换到该分支</strong></td></tr><tr><td><strong>git branch –track <branch><remote-branch></remote-branch></branch></strong></td><td><strong>新建一个分支，与指定的远程分支建立追踪关系</strong></td></tr><tr><td><strong>git checkout <branch-name></branch-name></strong></td><td><strong>切换到指定分支，并更新工作区</strong></td></tr><tr><td><strong>git branch -d <branch-name></branch-name></strong></td><td><strong>删除分支</strong></td></tr><tr><td><strong>git push origin –delete <branch-name></branch-name></strong></td><td><strong>删除远程分支</strong></td></tr></tbody></table><p>关于分支的操作虽然比较多，但都比较简单好记。</p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-29417c3862d0599c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>merge命令把不同的分支合并起来。如上图，在实际开放中，我们可能从master分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的commit记录，最后开发完成需要合入master中，这便用到了merge。</p><table><thead><tr><th><strong>git fetch <remote></remote></strong></th><th><strong>merge之前先拉一下远程仓库最新代码</strong></th></tr></thead><tbody><tr><td><strong>git merge <branch></branch></strong></td><td><strong>合并指定分支到当前分支</strong></td></tr></tbody></table><p>一般在merge之后，会出现conflict，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。如下图所示，需要手动解除。</p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-70440791ecd54631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-8d4e5fc624c0a23b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>rebase又称为衍合，是合并的另外一种选择。</p><p>在开始阶段，我们处于new分支上，执行<code>git rebase dev</code>，那么new分支上新的commit都在master分支上重演一遍，最后checkout切换回到new分支。这一点与merge是一样的，合并前后所处的分支并没有改变。<code>git rebase dev</code>，通俗的解释就是new分支想站在dev的肩膀上继续下去。rebase也需要手动解决冲突。</p><p><strong>rebase与merge的区别</strong></p><p>现在我们有这样的两个分支,test和master，提交如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      D---E test</span><br><span class="line">     /</span><br><span class="line">A---B---C---F master</span><br></pre></td></tr></table></figure><p>在master执行<code>git merge test</code>,然后会得到如下结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      D--------E</span><br><span class="line">     /          \</span><br><span class="line">A---B---C---F----G   test, master</span><br></pre></td></tr></table></figure><p>在master执行<code>git rebase test</code>，然后得到如下结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A---B---D---E---C<span class="string">'---F'</span>   test, master</span><br></pre></td></tr></table></figure><p>可以看到，merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。</p><p>如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase<br>如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge</p><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-2d41240c43bc3f2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。</p><table><thead><tr><th><strong>git reset —soft <commit></commit></strong></th><th>只改变提交点，暂存区和工作目录的内容都不改变</th></tr></thead><tbody><tr><td><strong>git reset —mixed <commit></commit></strong></td><td><strong>改变提交点，同时改变暂存区的内容</strong></td></tr><tr><td><strong>git reset —hard <commit></commit></strong></td><td><strong>暂存区、工作区的内容都会被修改到与提交点完全一致的状态</strong></td></tr><tr><td><strong>git reset –hard HEAD</strong></td><td><strong>让工作区回到上次提交时的状态</strong></td></tr></tbody></table><h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-02aab40cb9b6efb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>git revert用一个新提交来消除一个历史提交所做的任何修改。</p><p><strong>revert与reset的区别</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/3985563-93d402b6ebda56f8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。</li><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看<a href="http://yijiebuyi.com/blog/8f985d539566d0bf3b804df6be4e0c90.html" target="_blank" rel="noopener">这篇文章</a>。</li><li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li></ul><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>上传本地仓库分支到远程仓库分支，实现同步。</p><table><thead><tr><th>git push <remote><branch></branch></remote></th><th>上传本地指定分支到远程仓库</th></tr></thead><tbody><tr><td><strong>git push <remote> –force</remote></strong></td><td><strong>强行推送当前分支到远程仓库，即使有冲突</strong></td></tr><tr><td><strong>git push <remote> –all</remote></strong></td><td><strong>推送所有分支到远程仓库</strong></td></tr></tbody></table><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><table><thead><tr><th>git status</th><th>显示有变更的文件</th></tr></thead><tbody><tr><td><strong>git log</strong></td><td><strong>显示当前分支的版本历史</strong></td></tr><tr><td><strong>git diff</strong></td><td><strong>显示暂存区和工作区的差异</strong></td></tr><tr><td><strong>git diff HEAD</strong></td><td><strong>显示工作区与当前分支最新commit之间的差异</strong></td></tr><tr><td><strong>git cherry-pick <commit></commit></strong></td><td><strong>选择一个commit，合并进当前分支</strong></td></tr></tbody></table><p>以上就是关于Git的一些常用命令及详细阐述，相信能对Git有一个初步的认识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在日常工作中，经常会用到Git操作。但是对于新人来讲，刚上来对Git很陌生，操作起来也很懵逼。本篇文章主要针对刚开始接触Git的新人，理解Git的基本原理，掌握常用的一些命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、Git工作流程
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://lrh1993.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Circular-Reveal动画让页面跳转更炫酷</title>
    <link href="https://lrh1993.github.io/2017/08/16/%E4%BD%BF%E7%94%A8Circular-Reveal%E5%8A%A8%E7%94%BB%E8%AE%A9%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%9B%B4%E7%82%AB%E9%85%B7/"/>
    <id>https://lrh1993.github.io/2017/08/16/使用Circular-Reveal动画让页面跳转更炫酷/</id>
    <published>2017-08-16T11:58:57.000Z</published>
    <updated>2017-08-18T10:00:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android 5.0中引入了很多炫酷的动画效果，<strong>Circular Reveal</strong>便是其中一种。使用起来很简单，但效果却是意想不到的炫酷，让你的app更有逼格。</p></blockquote><h3 id="一、效果"><a href="#一、效果" class="headerlink" title="一、效果"></a>一、效果</h3><p>废话不说，下面的gif图中使用<strong>Circular Reveal</strong>动画实现跳转到搜索页的效果。gif图压缩宽高比失真了，不过效果还在。源码在最下面，可以下载体验下。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-ce00b62b862a3948.gif?imageMogr2/auto-orient/strip" alt=""></p><h3 id="二、Circular-Reveal介绍"><a href="#二、Circular-Reveal介绍" class="headerlink" title="二、Circular Reveal介绍"></a>二、Circular Reveal介绍</h3><p>当您显示或隐藏一组 UI 元素时，揭露动画可为用户提供视觉连续性。</p><p>ViewAnimationUtils.createCircularReveal()方法让您能够为裁剪区域添加动画以揭露或隐藏视图。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="meta">@param</span> view The View will be clipped to the animating circle.</span><br><span class="line">     * <span class="meta">@param</span> centerX The x coordinate of the center of the animating circle, relative to</span><br><span class="line">     *                &lt;code&gt;view&lt;/code&gt;.</span><br><span class="line">     * <span class="meta">@param</span> centerY The y coordinate of the center of the animating circle, relative to</span><br><span class="line">     *                &lt;code&gt;view&lt;/code&gt;.</span><br><span class="line">     * <span class="meta">@param</span> startRadius The starting radius of the animating circle.</span><br><span class="line">     * <span class="meta">@param</span> endRadius The ending radius of the animating circle.</span><br><span class="line">     */</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animator <span class="title">createCircularReveal</span><span class="params">(View view,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> centerX,  <span class="keyword">int</span> centerY, <span class="keyword">float</span> startRadius, <span class="keyword">float</span> endRadius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RevealAnimator(view, centerX, centerY, startRadius, endRadius);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ViewAnimationUtils.createCircularReveal()方法所执行的效果，就是将一个View裁剪成圆，然后从圆心逐渐揭露展现视图。</p><table><thead><tr><th>参数</th><th style="text-align:right">参数说明</th></tr></thead><tbody><tr><td>view</td><td style="text-align:right">要执行动画效果的View</td></tr><tr><td>centerX</td><td style="text-align:right">圆心x坐标</td></tr><tr><td>centerY</td><td style="text-align:right">圆心y坐标</td></tr><tr><td>startRadius</td><td style="text-align:right">开始时的圆半径</td></tr><tr><td>endRadius</td><td style="text-align:right">结束时的圆半径</td></tr></tbody></table><h3 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-30cdc1373f06bf06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>从上图可以看出，需要揭露展现的View是整个视图的根布局。开始的位置就是🔍图标的x，y坐标。开始的半径为0，结束的半径是上面那条斜边的长度。知道了这些参数，那么实现就简单了。<br>以下代码使用Kotlin实现，不过和java区别不大，不影响看懂原理。</p><h4 id="1-动画参数"><a href="#1-动画参数" class="headerlink" title="1.动画参数"></a>1.动画参数</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">"NewApi"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">actionOtherVisible</span><span class="params">(isShow: <span class="type">Boolean</span>, triggerView: <span class="type">View</span>, animView: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//判断API是否大于21</span></span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &lt; android.os.Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShow) &#123;</span><br><span class="line">                animView.visibility = View.VISIBLE</span><br><span class="line">                <span class="keyword">if</span> (mListener != <span class="literal">null</span>) mListener!!.onShowAnimationEnd()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                animView.visibility = View.GONE</span><br><span class="line">                <span class="keyword">if</span> (mListener != <span class="literal">null</span>) mListener!!.onHideAnimationEnd()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算 triggerView(即搜索按钮) 的中心位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> tvLocation = IntArray(<span class="number">2</span>)</span><br><span class="line">        triggerView.getLocationInWindow(tvLocation)</span><br><span class="line">        <span class="keyword">val</span> tvX = tvLocation[<span class="number">0</span>] + triggerView.width / <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> tvY = tvLocation[<span class="number">1</span>] + triggerView.height / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算 animView(即根布局) 的中心位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> avLocation = IntArray(<span class="number">2</span>)</span><br><span class="line">        animView.getLocationInWindow(avLocation)</span><br><span class="line">        <span class="keyword">val</span> avX = avLocation[<span class="number">0</span>] + animView.width / <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> avY = avLocation[<span class="number">1</span>] + animView.height / <span class="number">2</span></span><br><span class="line">        <span class="comment">//计算宽高</span></span><br><span class="line">        <span class="keyword">val</span> rippleW = <span class="keyword">if</span> (tvX &lt; avX) animView.width - tvX <span class="keyword">else</span> tvX - avLocation[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">val</span> rippleH = <span class="keyword">if</span> (tvY &lt; avY) animView.height - tvY <span class="keyword">else</span> tvY - avLocation[<span class="number">1</span>]</span><br><span class="line">       <span class="comment">//勾股定理求斜边</span></span><br><span class="line">        <span class="keyword">val</span> maxRadius = Math.sqrt((rippleW * rippleW + rippleH * rippleH).toDouble()).toFloat()</span><br><span class="line">        <span class="keyword">val</span> startRadius: <span class="built_in">Float</span></span><br><span class="line">        <span class="keyword">val</span> endRadius: <span class="built_in">Float</span></span><br><span class="line">        <span class="comment">//根据展示或隐藏设置起始与结束的半径</span></span><br><span class="line">        <span class="keyword">if</span> (isShow) &#123;</span><br><span class="line">            startRadius = <span class="number">0</span>f</span><br><span class="line">            endRadius = maxRadius</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startRadius = maxRadius</span><br><span class="line">            endRadius = <span class="number">0</span>f</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> anim = ViewAnimationUtils.createCircularReveal(animView, tvX, tvY, startRadius, endRadius)</span><br><span class="line">        animView.visibility = View.VISIBLE</span><br><span class="line">        anim.duration = DURATION</span><br><span class="line">        anim.interpolator = DecelerateInterpolator()</span><br><span class="line">        <span class="comment">//监听动画结束，进行回调</span></span><br><span class="line">        anim.addListener(<span class="keyword">object</span> : AnimatorListenerAdapter() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationEnd</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.onAnimationEnd(animation)</span><br><span class="line">                <span class="keyword">if</span> (isShow) &#123;</span><br><span class="line">                    animView.visibility = View.VISIBLE</span><br><span class="line">                    <span class="keyword">if</span> (mListener != <span class="literal">null</span>) mListener!!.onShowAnimationEnd()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    animView.visibility = View.GONE</span><br><span class="line">                    <span class="keyword">if</span> (mListener != <span class="literal">null</span>) mListener!!.onHideAnimationEnd()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        anim.start()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码中注释清楚解析了动画参数的获取和执行过程。</p><h4 id="2-动画调用"><a href="#2-动画调用" class="headerlink" title="2.动画调用"></a>2.动画调用</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(triggerView: <span class="type">View</span>, showView: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        actionOtherVisible(<span class="literal">true</span>, triggerView, showView)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hide</span><span class="params">(triggerView: <span class="type">View</span>, hideView: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        actionOtherVisible(<span class="literal">false</span>, triggerView, hideView)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>actionOtherVisible()方法根据传入true/false来确定是执行展示或隐藏动画。</p><h4 id="3-动画调用时机"><a href="#3-动画调用时机" class="headerlink" title="3.动画调用时机"></a>3.动画调用时机</h4><p>在SearchFragment中，监听第一帧的绘制，开启动画。其中mRootView就是根布局View。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreDraw</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        iv_search_search.viewTreeObserver.removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">        mCircularRevealAnim.show(iv_search_search, mRootView);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动画结束调用时机：①在点击搜索，跳转到搜索结果界面。②物理回退键回退。③点击回退按钮</p><p>再以上三个地方都可以调用hide()方法，实现隐藏动画。</p><h4 id="4-监听回调"><a href="#4-监听回调" class="headerlink" title="4.监听回调"></a>4.监听回调</h4><p>在上面配置动画参数的过程中，对动画结束进行了监听回调。调用了AnimListener接口的onHideAnimationEnd()和onShowAnimationEnd()方法，来实现回调。所有在SearchFragment中实现该接口，来监听回调。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onHideAnimationEnd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    et_search_keyword.setText(<span class="string">""</span>);</span><br><span class="line">    dismiss();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onShowAnimationEnd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isVisible) &#123;</span><br><span class="line">        KeyBoardUtils.openKeyboard(activity, et_search_keyword);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听到隐藏动画结束的时候，调用dismiss()方法关闭该DialogFragment。监听展现动画结束的时候，开启输入法框。</p><p>就是这么简单，通过以上方式就可以实现如此炫酷的效果。</p><p><strong>Github地址：</strong><a href="https://github.com/LRH1993/Eyepetizer-in-Kotlin/tree/master/app/src/main/java/com/tt/lvruheng/eyepetizer/search" target="_blank" rel="noopener">搜索页Circular Reveal动画</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Android 5.0中引入了很多炫酷的动画效果，&lt;strong&gt;Circular Reveal&lt;/strong&gt;便是其中一种。使用起来很简单，但效果却是意想不到的炫酷，让你的app更有逼格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://lrh1993.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>FloatingDragButton:炫酷的拖拽浮动按钮</title>
    <link href="https://lrh1993.github.io/2017/08/10/FloatingDragButton-%E7%82%AB%E9%85%B7%E7%9A%84%E6%8B%96%E6%8B%BD%E6%B5%AE%E5%8A%A8%E6%8C%89%E9%92%AE/"/>
    <id>https://lrh1993.github.io/2017/08/10/FloatingDragButton-炫酷的拖拽浮动按钮/</id>
    <published>2017-08-10T10:11:21.000Z</published>
    <updated>2017-08-12T08:37:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IOS的Assistive Touch效果很炫酷，可以任意拖拽，同时点击后会展开菜单栏。然而，这不只是IOS的特权，Android也可以实现。但是由于悬浮窗需要申请权限，所以本文仅在app内实现，可以任意拖拽，并可以响应点击事件。</p></blockquote><h3 id="一、效果图"><a href="#一、效果图" class="headerlink" title="一、效果图"></a>一、效果图</h3><p><img src="http://upload-images.jianshu.io/upload_images/3985563-af04304be7f81dea.gif?imageMogr2/auto-orient/strip" alt=""><br>效果还是不错的。上图看出虽然没有像IOS一样弹出菜单栏，仅仅以Toast和旋转动画的效果代替了（因为太懒了，更炫酷的效果交给你们的想象了）。但是确实支持点击事件，并且和拖拽事件不冲突。</p><p><strong>Github地址：<a href="https://github.com/LRH1993/FloatingDragButton" target="_blank" rel="noopener">FloatingDragButton</a></strong></p><h3 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h3><h4 id="1、拖拽实现"><a href="#1、拖拽实现" class="headerlink" title="1、拖拽实现"></a>1、拖拽实现</h4><p>很简单，设置TouchListener监听，实现onTouch方法，在ACTION_MOVE的过程中随着x,y坐标的移动更新浮动按钮的位置。<br>下面具体介绍重写onTouch方法的具体实现。</p><p><strong>监听ACTION_DOWN事件</strong><br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_DOWN:&#123;</span><br><span class="line">                mDownPointerId = MotionEventCompat.getPointerId(<span class="keyword">event</span>, <span class="number">0</span>);</span><br><span class="line">                mPreviousX = <span class="keyword">event</span>.getRawX();</span><br><span class="line">                mPreviousY = <span class="keyword">event</span>.getRawY();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p>记录初始的坐标以及触摸点。</p><p><strong>监听ACTION_MOVE事件</strong><br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:&#123;</span><br><span class="line">                <span class="keyword">if</span> (mDownPointerId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> <span class="keyword">index</span> = MotionEventCompat.getActionIndex(event);</span><br><span class="line">                    <span class="keyword">int</span> id = MotionEventCompat.getPointerId(event, <span class="keyword">index</span>);</span><br><span class="line">                    <span class="keyword">if</span> (id == mDownPointerId) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> update = adjustMarginParams(view, event);</span><br><span class="line">                        <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mFloatView.requestLayout();</span><br><span class="line">                        mHasMoved = <span class="keyword">true</span>;</span><br><span class="line">                        result = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p>其中最重要的是adjustMarginParams(view, event)方法，来更新浮动按钮的相对位置。<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> boolean adjustMarginParams(View v, MotionEvent event) &#123;</span><br><span class="line">        float x =  event.getRawX();</span><br><span class="line">        float y =  event.getRawY();</span><br><span class="line">        float deltaX = x - mPreviousX;</span><br><span class="line">        float deltaY = y - mPreviousY;</span><br><span class="line">        <span class="keyword">if</span> (!mHasMoved) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(deltaX) &lt; mTouchSlop &amp;&amp; Math.abs(deltaY) &lt; mTouchSlop) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左上角位置</span></span><br><span class="line">        int <span class="keyword">new</span><span class="type">X</span> = (int)x - mFloatView.getWidth() / <span class="number">2</span>;</span><br><span class="line">        int <span class="keyword">new</span><span class="type">Y</span> = (int)y - mFloatView.getHeight() / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">new</span><span class="type">X</span> = Math.max(<span class="keyword">new</span><span class="type">X</span>, mBoundsInScreen.left + mEdgePaddingLeft);</span><br><span class="line">        <span class="keyword">new</span><span class="type">X</span> = Math.min(<span class="keyword">new</span><span class="type">X</span>, mBoundsInScreen.right - mEdgePaddingRight - mFloatView.getWidth());</span><br><span class="line">        <span class="keyword">new</span><span class="type">Y</span> = Math.max(<span class="keyword">new</span><span class="type">Y</span>, mBoundsInScreen.top + mEdgePaddingTop);</span><br><span class="line">        <span class="keyword">new</span><span class="type">Y</span> = Math.min(<span class="keyword">new</span><span class="type">Y</span>, mBoundsInScreen.bottom - mEdgePaddingBottom - mFloatView.getHeight());</span><br><span class="line">        mFloatViewWindowParam.x = <span class="keyword">new</span><span class="type">X</span>;</span><br><span class="line">        mFloatViewWindowParam.y = <span class="keyword">new</span><span class="type">Y</span> - mParentMarginTop;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中mBoundsInScreen代表浮动按钮可移动的矩形范围。</p><p>根据当前event内的坐标与mBoundsInScreen范围比较，选择最终拖拽到达的位置，设置给浮动按钮的布局参数mFloatViewWindowParam，然后调用requestLayout更新布局。</p><p><strong>监听ACTION_UP/ACTION_CANCEL</strong><br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:&#123;</span><br><span class="line">                <span class="keyword">if</span> (mDownPointerId &gt;= <span class="number">0</span> &amp;&amp; mHasMoved) &#123;</span><br><span class="line">                    event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">                    adjustMarginParams(view, event);</span><br><span class="line">                    mFloatView.requestLayout();</span><br><span class="line">                    <span class="built_in">int</span> center = (mBoundsInScreen.<span class="built_in">width</span>() - mFloatView.getWidth()) / <span class="number">2</span>;</span><br><span class="line">                    <span class="built_in">int</span> x = mFloatViewWindowParam.x;</span><br><span class="line">                    <span class="built_in">int</span> destX = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">int</span> posX = Gravity.LEFT;</span><br><span class="line">                    <span class="comment">//抬起时 根据位置强制把浮动按钮归于左边或右边</span></span><br><span class="line">                    <span class="keyword">if</span> (x &lt; center) &#123; <span class="comment">// 左边</span></span><br><span class="line">                        destX = mBoundsInScreen.left + mEdgePaddingLeft;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        posX = Gravity.RIGHT;</span><br><span class="line">                        destX = mBoundsInScreen.right - mEdgePaddingRight - mFloatView.getWidth();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (mFloatButtonCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="built_in">float</span> posY = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (mBoundsInScreen.<span class="built_in">height</span>() - mFloatView.getHeight() != <span class="number">0</span>) &#123;</span><br><span class="line">                            posY = <span class="number">1</span>f * (mFloatViewWindowParam.y - mBoundsInScreen.top) / (mBoundsInScreen.<span class="built_in">height</span>() - mFloatView.getHeight());</span><br><span class="line">                        &#125;</span><br><span class="line">                        mFloatButtonCallback.onPositionChanged(destX, mFloatViewWindowParam.y, posX, posY);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">int</span> deltaHorizon = destX - x;</span><br><span class="line">                    <span class="comment">//小于100直接移动 否则开启动画</span></span><br><span class="line">                    <span class="keyword">if</span> (Math.<span class="built_in">abs</span>(deltaHorizon) &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                        mFloatViewWindowParam.x = destX;</span><br><span class="line">                        mFloatView.requestLayout();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ValueAnimator animator = ValueAnimator.ofInt(x, destX);</span><br><span class="line">                        animator.setInterpolator(mInterpolator);</span><br><span class="line">                        <span class="keyword">if</span> (mUpdateListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mUpdateListener = <span class="keyword">new</span> FloatAnimatorUpdateListener();</span><br><span class="line">                            mUpdateListener.setUpdateView(FloatTouchListener.<span class="keyword">this</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        animator.addUpdateListener(mUpdateListener);</span><br><span class="line">                        animator.setDuration(<span class="number">200</span>);</span><br><span class="line">                        animator.start();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                resetStatus();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>实现当抬起的瞬间，根据当前所处坐标靠左还是靠右，把浮动按钮置于左边缘或者右边缘。同时，调用回调，把移动相对位置传给回调函数，实现拖拽监听。</p><p>当从当前位置移动到左/右边缘的距离小于100时，直接移动，否则实现动画减速移动效果。</p><p>如此简单便可实现任意拖拽的效果了，具体一些细节要细看源码实现。</p><h3 id="2-点击实现"><a href="#2-点击实现" class="headerlink" title="2.点击实现"></a>2.点击实现</h3><p>也许有人会认为点击事件很好实现啊，setOnClickListener()设置个监听就可以实现了。不信你去试试，没用。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-5d5e17048919efeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>其实点击实现才是本篇文章的精髓，因为灵活应用到了事件分发机制。</p><p>从事件分发机制中我们知道，就优先级而言：onTouchListener&gt;onClickListenr。</p><p>上面的拖拽事件已经消费了onTouchListener(即onTouch方法中返回true)，那么就不会下发到onClickListenr，自然就不会产生点击事件。</p><p>也许你想让onTouchListener不消费，然后不就下发到onClickListenr了么？</p><p>确实这样可以实现点击事件，但是拖拽功能又实现不了了。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-2ea50d1cbffd634a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>因为onTouch方法中返回false,确实onClickListenr接收到了事件，然后消费掉。可是因为onTouch方法中返回false，所以接下来的一切事件不能接受，没办法响应拖拽效果了。</p><p>通过上面的分析，最终的解决办法就是：onTouch方法中，在接收到ACTION_DOWN后，返回false，交给onClickListenr处理。剩下的ACTION_MOVE/ACTION_UP等事件，返回true，交给onTouchListener处理，这样自然就可以既实现拖拽效果又实现点击效果了。</p><p>具体实现以下面伪代码为例<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">public boolean onTouch(View view, MotionEvent event) &#123;</span><br><span class="line">      int action = MotionEventCompat.getActionMasked(event);</span><br><span class="line">      <span class="keyword">if</span> (mFloatButtonCallback != null) &#123;</span><br><span class="line">          mFloatButtonCallback.onTouch();</span><br><span class="line">      &#125;</span><br><span class="line">      boolean result = false;</span><br><span class="line">      switch (action) &#123;</span><br><span class="line">          <span class="keyword">case</span> MotionEvent.ACTION_DOWN:&#123;</span><br><span class="line">             ....................................................</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> MotionEvent.ACTION_MOVE:&#123;</span><br><span class="line">             ....................................................</span><br><span class="line">              result = true;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">          <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:&#123;</span><br><span class="line">              ................................................</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>原理就是这么简单，更加炫酷的效果可自定义实现，喜欢就点个star支持下吧！</p><p><strong>Github地址：<a href="https://github.com/LRH1993/FloatingDragButton" target="_blank" rel="noopener">https://github.com/LRH1993/FloatingDragButton</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;IOS的Assistive Touch效果很炫酷，可以任意拖拽，同时点击后会展开菜单栏。然而，这不只是IOS的特权，Android也可以实现。但是由于悬浮窗需要申请权限，所以本文仅在app内实现，可以任意拖拽，并可以响应点击事件。&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="Android进阶" scheme="https://lrh1993.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>关于TCP/IP，必知必会的十个问题</title>
    <link href="https://lrh1993.github.io/2017/08/06/%E5%85%B3%E4%BA%8ETCP-IP%EF%BC%8C%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%E5%8D%81%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>https://lrh1993.github.io/2017/08/06/关于TCP-IP，必知必会的十个问题/</id>
    <published>2017-08-06T08:54:21.000Z</published>
    <updated>2017-08-06T01:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理了一些TCP/IP协议簇中需要必知必会的十大问题，既是面试高频问题，又是程序员必备基础素养。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3985563-6a2435e7e077844a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP/IP十个问题"></p><h3 id="一、TCP-IP模型"><a href="#一、TCP-IP模型" class="headerlink" title="一、TCP/IP模型"></a>一、TCP/IP模型</h3><p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p><p>基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-0cc2edef95a71669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-8a876f4d031aeacf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-bc8f28f9d6c40ed5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上图以HTTP协议为例，具体说明。</p><h3 id="二、数据链路层"><a href="#二、数据链路层" class="headerlink" title="二、数据链路层"></a>二、数据链路层</h3><p>物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-626f9f89f361c492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。</li><li>透明传输:零比特填充、转义字符。</li><li>可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。</li><li>差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。</li></ul><h3 id="三、网络层"><a href="#三、网络层" class="headerlink" title="三、网络层"></a>三、网络层</h3><h4 id="1-IP协议"><a href="#1-IP协议" class="headerlink" title="1.IP协议"></a>1.IP协议</h4><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p><h5 id="1-1-IP地址"><a href="#1-1-IP地址" class="headerlink" title="1.1 IP地址"></a>1.1 IP地址</h5><p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p><p>32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p><p> A类IP地址: 0.0.0.0~127.0.0.0<br>B类IP地址:128.0.0.1~191.255.0.0<br>C类IP地址:192.168.0.0~239.255.255.0</p><h5 id="1-2-IP协议头"><a href="#1-2-IP协议头" class="headerlink" title="1.2 IP协议头"></a>1.2 IP协议头</h5><p><img src="http://upload-images.jianshu.io/upload_images/3985563-f17dbaa542787fdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p><h4 id="2-ARP及RARP协议"><a href="#2-ARP及RARP协议" class="headerlink" title="2.ARP及RARP协议"></a>2.ARP及RARP协议</h4><p>ARP 是根据IP地址获取MAC地址的一种协议。</p><p>ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。</p><p>如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。</p><p>而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。</p><p>RARP协议的工作与此相反，不做赘述。</p><h4 id="3-ICMP协议"><a href="#3-ICMP协议" class="headerlink" title="3. ICMP协议"></a>3. ICMP协议</h4><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。</p><p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。</p><h3 id="四、ping"><a href="#四、ping" class="headerlink" title="四、ping"></a>四、ping</h3><p>ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p><p>例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:<br><img src="http://upload-images.jianshu.io/upload_images/3985563-afb5d86aa0a3a136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。</p><p>ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。</p><h3 id="五、Traceroute"><a href="#五、Traceroute" class="headerlink" title="五、Traceroute"></a>五、Traceroute</h3><p>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p><p>Traceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-05337f62b96c8e02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="六、TCP-UDP"><a href="#六、TCP-UDP" class="headerlink" title="六、TCP/UDP"></a>六、TCP/UDP</h3><p>TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-4bcddf13416e9f0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h5><p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p><h5 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h5><p>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p><p>关于拥塞控制，流量控制，是TCP的重点，后面讲解。</p><p>TCP和UDP协议的一些应用<br><img src="http://upload-images.jianshu.io/upload_images/3985563-d68974689d48cee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="什么时候应该使用TCP？"><a href="#什么时候应该使用TCP？" class="headerlink" title="什么时候应该使用TCP？"></a>什么时候应该使用TCP？</h4><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 </p><h4 id="什么时候应该使用UDP？"><a href="#什么时候应该使用UDP？" class="headerlink" title="什么时候应该使用UDP？"></a>什么时候应该使用UDP？</h4><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 </p><h3 id="七、DNS"><a href="#七、DNS" class="headerlink" title="七、DNS"></a>七、DNS</h3><p>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。</p><h3 id="八、TCP连接的建立与终止"><a href="#八、TCP连接的建立与终止" class="headerlink" title="八、TCP连接的建立与终止"></a>八、TCP连接的建立与终止</h3><h4 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1.三次握手"></a>1.三次握手</h4><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-cd5a153e44696643.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>第一次握手：</strong> 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；    </p><p><strong>第二次握手：</strong> 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；  </p><p><strong>第三次握手：</strong> 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><h5 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h5><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><h4 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2.四次挥手"></a>2.四次挥手</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-6fdf680296f3acd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>第一次分手：</strong> 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p><strong>第二次分手：</strong> 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p><strong>第三次分手：</strong> 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p><strong>第四次分手：</strong> 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><h5 id="为什么要四次分手？"><a href="#为什么要四次分手？" class="headerlink" title="为什么要四次分手？"></a>为什么要四次分手？</h5><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><h5 id="为什么要等待2MSL？"><a href="#为什么要等待2MSL？" class="headerlink" title="为什么要等待2MSL？"></a>为什么要等待2MSL？</h5><p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。<br>原因有二：</p><ul><li>保证TCP协议的全双工连接能够可靠关闭</li><li>保证这次连接的重复数据段从网络中消失</li></ul><p>第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p><p>第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p><h3 id="九、TCP流量控制"><a href="#九、TCP流量控制" class="headerlink" title="九、TCP流量控制"></a>九、TCP流量控制</h3><p> 如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓<strong>流量控制</strong>就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p><p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-846230b2b91e5696.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。</p><p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</p><h3 id="十、TCP拥塞控制"><a href="#十、TCP拥塞控制" class="headerlink" title="十、TCP拥塞控制"></a>十、TCP拥塞控制</h3><h4 id="1-慢开始和拥塞避免"><a href="#1-慢开始和拥塞避免" class="headerlink" title="1.慢开始和拥塞避免"></a>1.慢开始和拥塞避免</h4><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><h5 id="慢开始算法："><a href="#慢开始算法：" class="headerlink" title="慢开始算法："></a>慢开始算法：</h5><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。<br>因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p><p>通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-470235b1e99d8111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。<strong>一个传输轮次所经历的时间其实就是往返时间RTT。</strong>不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p><p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p><p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：</p><ul><li>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</li></ul><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>让拥塞窗口cwnd缓慢地增大，即每经过<strong>一个往返时间RTT</strong>就把发送方的<strong>拥塞窗口cwnd加1，而不是加倍</strong>。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-8bbeee141535e125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p><p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-4ca562045be9350d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="2-快重传和快恢复"><a href="#2-快重传和快恢复" class="headerlink" title="2.快重传和快恢复"></a>2.快重传和快恢复</h4><h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-3e4f9c585200ed18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。</p><p>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p><p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p><p><strong>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</strong></p><p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ul><li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。</li><li>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。<br><img src="http://upload-images.jianshu.io/upload_images/3985563-8e0bf3c2c9554f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文整理了一些TCP/IP协议簇中需要必知必会的十大问题，既是面试高频问题，又是程序员必备基础素养。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_ima
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://lrh1993.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
